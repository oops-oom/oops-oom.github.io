<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">






<link rel="stylesheet" href="/css/main.css?v=7.2.0">






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">








<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="Lua is an embedded language. This means that Lua is not a stand-alone pack- age, but a library that we can link with other applications to incorporate Lua facilities into them.You may be wondering: i">
<meta property="og:type" content="article">
<meta property="og:title" content="Chapter 25 - An Overview of the C API">
<meta property="og:url" content="http://yoursite.com/2019/07/27/programming_in_lua/Chapter 25 - An Overview of the C API/index.html">
<meta property="og:site_name" content="Know Why">
<meta property="og:description" content="Lua is an embedded language. This means that Lua is not a stand-alone pack- age, but a library that we can link with other applications to incorporate Lua facilities into them.You may be wondering: i">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-07-27T15:14:54.442Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 25 - An Overview of the C API">
<meta name="twitter:description" content="Lua is an embedded language. This means that Lua is not a stand-alone pack- age, but a library that we can link with other applications to incorporate Lua facilities into them.You may be wondering: i">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/07/27/programming_in_lua/Chapter 25 - An Overview of the C API/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>Chapter 25 - An Overview of the C API | Know Why</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Know Why</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/programming_in_lua/Chapter 25 - An Overview of the C API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binnnliu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Know Why">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Chapter 25 - An Overview of the C API

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-27 23:14:54" itemprop="dateCreated datePublished" datetime="2019-07-27T23:14:54+08:00">2019-07-27</time>
            </span>
          

          

          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>Lua is an embedded language. This means that Lua is not a stand-alone pack- age, but a library that we can link with other applications to incorporate Lua facilities into them.<br>You may be wondering: <strong>if Lua is not a stand-alone program, how come we have been using Lua stand-alone through the whole book until now</strong>? The solution to this puzzle is the Lua interpreter (the executable lua). This interpreter is a tiny application (with less than five hundred lines of code) that uses the Lua library to implement the stand-alone interpreter. This program handles the interface with the user, taking her files and strings to feed them to the Lua library, which does the bulk of the work (such as actually running Lua code).</p>
</blockquote>
<p>lua是一门嵌入式的语言。</p>
<blockquote>
<p>This ability to be used as a library to extend an application is what makes Lua an <strong>extension language</strong>. At the same time, a program that uses Lua can register new functions in the Lua environment; such functions are implemented in C (or another language), so that they can add facilities that cannot be written directly in Lua. This is what makes Lua an <strong>extensible language</strong>.<br>These two views of Lua (as an extension language and as an extensible language) correspond to two kinds of interaction between C and Lua. In the first kind, C has the control and Lua is the library. The C code in this kind of interaction is what we call <strong>application code</strong>. In the second kind, Lua has the control and C is the library. Here, the C code is called <strong>library code</strong>. <strong>Both application code and library code use the same API to communicate with Lua, the so-called C API</strong>.<br>The C API is the set of functions that allow C code to interact with Lua. It comprises functions to read and write Lua global variables, to call Lua functions,o run pieces of Lua code, to register C functions so that they can later be called by Lua code, and so on. Virtually anything that Lua code can do can also be done by C code through the C API.</p>
</blockquote>
<p>extension language vs extensible language<br>application code      vs library code</p>
<blockquote>
<p><strong>The C API follows the modus operandi of C</strong>, which is quite different from the modus operandi of Lua. When programming in C, we must care about type checking, error recovery, memory-allocation errors, and several other sources of complexity. Most functions in the API do not check the correctness of their arguments; it is your responsibility to make sure that the arguments are valid before calling a function. If you make mistakes, you can get a “segmentation fault” error or something similar, instead of a well-behaved error message. Moreover, <strong>the API emphasizes flexibility and simplicity</strong>, sometimes at the cost of ease of use. Common tasks may involve several API calls. This may be boring, but it gives you full control over all details.</p>
</blockquote>
<p>C API遵循C的规则，与lua差异较大。<br>更重要的是，lua强调简单和灵活，甚至以易用性作为代价。</p>
<blockquote>
<p>As its title says, the goal of this chapter is to give an overview of what is involved when you use Lua from C. Do not bother understanding all the details of what is going on now. Later we will fill in the details. Nevertheless, do not forget that you always can find more details about specific functions in the Lua reference manual. Moreover, you can find several examples of the use of the API in the Lua distribution itself. <strong>The Lua stand-alone interpreter (lua.c) provides examples of application code, while the standard libraries (lmathlib.c, lstrlib.c, etc.) provide examples of library code.</strong><br>From now on, we are wearing a C programmers’ hat. When I talk about “you”, I mean you when programming in C, or you impersonated by the C code you write.</p>
</blockquote>
<p>本章仅仅是讲述一个模型。</p>
<blockquote>
<p>A major component in the communication between Lua and C is an omnipresent <strong>virtual stack</strong>. Almost all API calls operate on values on this stack. All data exchange from Lua to C and from C to Lua occurs through this stack. Moreover, you can use the stack to keep intermediate results too. The stack helps to solve two impedance mismatches between Lua and C: the first is caused by Lua being garbage collected, whereas C requires explicit deallocation; the second results from the shock between dynamic typing in Lua versus the static typing of C. We will discuss the stack in more detail in Section 25.2.</p>
</blockquote>
<p>无处不在的virtual stack负责：C与Lua交换数据；保存中间结果；<br>解决了lua与C交互的难题</p>
<ul>
<li>内存管理（GC）</li>
<li>静态类型和动态类型</li>
</ul>
<h3 id="25-1-A-First-Example"><a href="#25-1-A-First-Example" class="headerlink" title="25.1  A First Example"></a>25.1  A First Example</h3><blockquote>
<p>We will start this overview with a simple example of an application program: a stand-alone Lua interpreter. We can write a primitive stand-alone interpreter as in Listing 25.1. The header file lua.h defines the basic functions provided by Lua. It includes functions to create a new Lua environment, to invoke Lua functions (such as lua_pcall), to read and write global variables in the Lua environment, to register new functions to be called by Lua, and so on. Everything defined in lua.h has a lua_ prefix.</p>
</blockquote>
<p><em>Listing 25.1. A simple stand-alone Lua interpreter:</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lua.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lauxlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lualib.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    lua_State *L = luaL_newstate();</span><br><span class="line">    luaL_openlibs(L);        <span class="comment">/* opens the standard libraries */</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(buff, <span class="keyword">sizeof</span>(buff), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        error = luaL_loadstring(L, buff) || lua_pcall(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">            lua_pop(L, <span class="number">1</span>);  <span class="comment">/* pop error message from the stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_close(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The header file lauxlib.h defines the functions provided by the auxiliary library (auxlib). All its definitions start with luaL_ (e.g., luaL_loadstring). The auxiliary library uses the basic API provided by lua.h to provide a higher abstraction level, in particular with abstractions used by the standard libraries. The basic API strives for economy and orthogonality, whereas the auxiliary library strives for practicality for common tasks. Of course, it is very easy for your program to create other abstractions that it needs, too. Keep in mind that the auxiliary library has no access to the internals of Lua. It does its entire job through the official basic API. Whatever it does, your program can do.</p>
</blockquote>
<p>lua.h vs lauxlib.h 区别：</p>
<ol>
<li>lua_ vs luaL_；</li>
<li>lauxlib.h 提供更高层次的函数，基于lua.h。</li>
</ol>
<blockquote>
<p>The Lua library defines no global variables at all. It keeps all its state in the dynamic structure lua_State; <strong>all functions inside Lua receive a pointer to this structure as an argument.</strong> This implementation makes Lua reentrant and ready to be used in multithreaded code.</p>
</blockquote>
<p>lua library没有定义全局变量，所有的状态被保存在lua_State中；lua中所有的函数接收一个指向lua_State的参数。</p>
<blockquote>
<p>As its name implies, the luaL_newstate function creates a new Lua state. When luaL_newstate creates a fresh state, its environment contains no predefined functions, not even print. To keep Lua small, all standard libraries are provided as separate packages, so that you do not have to use them if you do not need to. The header file lualib.h defines functions to open the libraries. Function luaL_openlibs opens all standard libraries.</p>
</blockquote>
<p>刚创建好的Lua state是没有任何预定义的函数的，包括print。<br>为了使lua保持简单，所有的标准库都作为单独的包；我们可以选择性的载入我们需要的库。<br>lualib.h定义了库操作函数，luaL_openlibs加载所有标准库；</p>
<blockquote>
<p>After creating a state and <strong>populating</strong> it with the standard libraries, it is time to interpret the user input. For each line the user enters, the program first calls luaL_loadstring to compile the code. If there are no errors, the call returns zero and pushes the resulting function on the stack. (Remember that we will discuss this “magic” stack in detail in the next section.) Then the program calls lua_pcall, which pops the function from the stack and runs it in protected mode. Like luaL_loadstring, lua_pcall returns zero if there are no errors. In case of an error, both functions push an error message on the stack; we get this message with lua_tostring and, after printing it, we remove it from the stack with lua_pop.</p>
</blockquote>
<p>处理顺序</p>
<ol>
<li>lua_State *L = luaL_newstate(); </li>
<li>luaL_openlibs(L) </li>
<li>luaL_loadstring()  =&gt; compile code</li>
<li>lua_pcall()</li>
</ol>
<p>lua_pcall和luaL_loadstring如果没有错误，则返回0，并把运行结果压栈；如果有错误，会把错误信息压栈；</p>
<blockquote>
<p>Notice that, in case of error, this program simply prints the error message to the standard error stream. Real error handling can be quite complex in C, and how to do it depends on the nature of your application. <strong>The Lua core never writes anything directly to any output stream; it signals errors by returning error messages.</strong> Each application can handle these messages in a way most appropriate for its needs. To simplify our discussions, we will assume for now a simple error handler like the following one, which prints an error message, closes the Lua state, and exits from the whole application:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list argp;</span><br><span class="line">    va_start(argp, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, argp);</span><br><span class="line">    va_end(argp);</span><br><span class="line">    lua_close(L);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Later we will discuss more about error handling in the application code. Because you can compile Lua both as C and as C++ code, lua.h does not include this typical adjustment code that is present in several other C libraries:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>If you have compiled Lua as C code (the most common case) and are using it in C++, you can include lua.hpp instead of lua.h. It is defined as follows:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lua.h"</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何兼容C++，这里的extern是告诉C++编译器按照C的的规则翻译响应的函数名称。</p>
<h3 id="25-2-The-Stack"><a href="#25-2-The-Stack" class="headerlink" title="25.2 The Stack"></a>25.2 The Stack</h3><blockquote>
<p>We face two problems when trying to exchange values between Lua and C: the mismatch between a dynamic and a static type system and the mismatch between automatic and manual memory management.</p>
</blockquote>
<p>交互的两大困难： GC和动静类型；</p>
<blockquote>
<p>In Lua, when we write a[k]=v, both k and v can have several different types; even a can have different types, due to metatables. If we want to offer this operation in C, however, any given settable function must have a fixed type. We would need dozens of different functions for this single operation (one function for each combination of types<br>for the three arguments).</p>
</blockquote>
<p>lua动态类型，如果需要C支持lua的这些操作，就需要任何函数支持多种类型。</p>
<p>We could solve this problem by declaring some kind of union type in C— let us call it <strong>lua_Value</strong> — that could represent all Lua values. Then, we could declare settable as</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void lua_settable (lua_Value a, lua_Value k, lua_Value v);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This solution has two drawbacks. First, it can be difficult to map such a complex type to other languages; we designed Lua to interface easily not only with C/C++, but also with Java, Fortran, C#, and the like. Second, Lua does garbage collection: if we keep a Lua table in a C variable, the Lua engine has no way to know about this use; it may (wrongly) assume that this table is garbage and collect it.</p>
</blockquote>
<p>两个原因不采用lua_Value:</p>
<ol>
<li>与其他语言交互困难；</li>
<li>GC不易控制；</li>
</ol>
<blockquote>
<p>Therefore, the Lua API does not define anything like a lua_Value type. Instead, it uses an abstract stack to exchange values between Lua and C. Each slot in this stack can hold any Lua value. Whenever you want to ask for a value from Lua (such as the value of a global variable), you call Lua, which pushes the required value on the stack. Whenever you want to pass a value to Lua, you first push the value on the stack, and then you call Lua (which will pop the value). We still need a different function to push each C type on the stack and a different function to get each C type from the stack, but we avoid the combinatorial explosion. <strong>Moreover, because this stack lives inside Lua, the garbage collector knows which values C is using.</strong><br>Nearly all functions in the API use the stack. As we saw in our first example, luaL_loadstring leaves its result on the stack (either the compiled chunk or an error message); lua_pcall gets the function to be called from the stack and leaves any occasional error message there too.</p>
</blockquote>
<p>lua几乎所有的操作api都会操作vitual stack。</p>
<blockquote>
<p>Lua manipulates this stack in a strict LIFO discipline (Last In, First Out). When you call Lua, it changes only the top part of the stack. Your C code has more freedom; specifically, it can inspect any element inside the stack and even insert and delete elements in any arbitrary position.</p>
</blockquote>
<h4 id="Pushing-elements"><a href="#Pushing-elements" class="headerlink" title="Pushing elements"></a>Pushing elements</h4><blockquote>
<p>The API has one push function for each C type that can be represented in Lua: lua_pushnil for the constant nil, lua_pushboolean for booleans (integers, in C), lua_pushnumber for doubles, lua_pushinteger for integers, lua_pushunsigned for unsigned integers, lua_pushlstring for arbitrary strings (a pointer to char plus a length), and lua_pushstring for zero-terminated strings:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushnil</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushboolean</span><span class="params">(lua_State *L, <span class="keyword">int</span> <span class="keyword">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushnumber</span><span class="params">(lua_State *L, lua_Number n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushinteger</span><span class="params">(lua_State *L, lua_Integer n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushunsigned</span><span class="params">(lua_State *L, lua_Unsigned n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushlstring</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushstring</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>There are also functions to push C functions and userdata values on the stack; we will discuss them later.<br>The type lua_Number is the numeric type in Lua. It is a double by default, but some installations can change it to a float or even a long integer, to accommodate Lua to restricted machines. The type lua_Integer is a signed integral type large enough to store the size of large strings. Usually, it is defined as the ptrdiff_t type. The type lua_Unsigned is a 32-bit unsigned integral type in C; it is used by the bitwise library and related functions.</p>
</blockquote>
<blockquote>
<p><strong>Strings in Lua are not zero-terminated</strong>; they can contain arbitrary binary data. In consequence, they must rely on an explicit length. The basic function to push a string onto the stack is <code>lua_pushlstring</code>, which requires an ex- plicit length as an argument. For zero-terminated strings, you can use also <code>lua_pushstring</code>, which uses strlen to supply the string length. Lua never keeps pointers to external strings (or to any other external object except C functions, which are always static). For any string that it has to keep, Lua either makes an internal copy or reuses one. Therefore, you can free or modify your buffer as soon as these functions return.<br>Whenever you push an element onto the stack, <strong>it is your responsibility to ensure that the stack has space for it</strong>. Remember, you are a C programmer now; Lua will not spoil you. When Lua starts and any time that Lua calls C, the stack has at least 20 free slots. (The header file lua.h defines this constant as LUA_MINSTACK.) This space is more than enough for most common uses, so usually we do not even think about it. However, some tasks need more stack space, in particular if you have a loop pushing elements into the stack. In those cases, you may want to call lua_checkstack, which checks whether the stack has enough space for your needs:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lua_checkstack</span> <span class="params">(lua_State *L, <span class="keyword">int</span> sz)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="Querying-elements"><a href="#Querying-elements" class="headerlink" title="Querying elements"></a>Querying elements</h4><blockquote>
<p>To refer to elements in the stack, the API uses indices. The first element pushed on the stack has index 1, the next one has index 2, and so on until the top. We can also access elements using the top of the stack as our reference, using negative indices. In this case, ￼ 1 refers to the element at the top (that is, the last<br>element pushed), 2 to the previous element, and so on. For instance, the call lua_tostring(L,-1) returns the value at the top of the stack as a string. As we will see, there are several occasions when it is natural to index the stack from the bottom (that is, with positive indices), and several other occasions when the natural way is to use negative indices.</p>
</blockquote>
<p>stack index</p>
<blockquote>
<p>To check whether an element has a specific type, the API offers a family of functions lua_is *, where the * can be any Lua type. So, there are lua_isnumber, lua_isstring, lua_istable, and the like. All these functions have the same prototype:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lua_is* (lua_State *L, <span class="keyword">int</span> index);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Actually, lua_isnumber does not check <strong>whether the value has that specific type, but whether the value can be converted to that type</strong>; lua_isstring is similar: in particular, any number satisfies lua_isstring.<br>There is also a function lua_type, which returns the type of an element in the stack. Each type is represented by a constant defined in the header file lua.h: LUA_TNIL, LUA_TBOOLEAN, LUA_TNUMBER, LUA_TSTRING, LUA_TTABLE, LUA_TTHREAD, LUA_TUSERDATA, and LUA_TFUNCTION. We use this function mainly in conjunction with a switch statement. It is also useful when we need to check for strings and numbers without coercions.<br>To get a value from the stack, there are the lua_to* functions:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>          <span class="title">lua_toboolean</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>  *<span class="title">lua_tolstring</span><span class="params">(lua_State *L, <span class="keyword">int</span> index,  <span class="keyword">size_t</span> *len)</span></span>;</span><br><span class="line"><span class="function">lua_Number   <span class="title">lua_tonumber</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">lua_Integer  <span class="title">lua_tointeger</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">lua_Unsigned <span class="title">lua_tounsigned</span><span class="params">(lua_State *L, <span class="keyword">int</span> idx)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The lua_toboolean converts any Lua value to a C boolean (0 or 1), following the Lua rules for conditions: the values nil and false are false; any other value is true.<br><strong>It is OK to call any of the lua_to* functions even when the given element does not have an appropriate type.</strong> Function lua_toboolean works for any type; lua_tolstring returns NULL for non-string values. The numeric functions, however, have no way to signal a wrong type, so they simply return zero. Usually you would need to call lua_isnumber to check the type, but Lua 5.2 introduced the following new functions:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">lua_Number   <span class="title">lua_tonumberx</span><span class="params">(lua_State *L, <span class="keyword">int</span> idx, <span class="keyword">int</span> *isnum)</span></span>;</span><br><span class="line"><span class="function">lua_Integer  <span class="title">lua_tointegerx</span><span class="params">(lua_State *L, <span class="keyword">int</span> idx, <span class="keyword">int</span> *isnum)</span></span>;</span><br><span class="line"><span class="function">lua_Unsigned <span class="title">lua_tounsignedx</span><span class="params">(lua_State *L, <span class="keyword">int</span> idx, <span class="keyword">int</span> *isnum)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The out parameter isnum returns a boolean that indicates whether the Lua value is a number. (You can call those functions with NULL as the last parameter, if you do not need that value. The old lua_to* functions are now implemented as macros using this facility.)</p>
</blockquote>
<p>我们可以调用任何lua_to*系列函数，即使类型不匹配。如果超出正常index范围呢？</p>
<blockquote>
<p>The lua_tolstring function returns a pointer to an internal copy of the string and stores the string’s length in the position given by len. <strong>You cannot change this internal copy</strong> (there is a const there to remind you). Lua ensures that this pointer is valid as long as the corresponding string value is in the stack. When a C function called by Lua returns, Lua clears its stack; therefore, as a rule, you should never store pointers to Lua strings outside the function that got them.<br><strong>Any string that lua_tolstring returns always has an extra zero at its end, but it can have other zeros inside it.</strong> The size returned through the third argument, len, is the real string’s length. In particular, assuming that the value at the top of the stack is a string, the following assertions are always valid:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_t l;</span><br><span class="line">const char *s = lua_tolstring(L, -1, &amp;l);   /* any Lua string */</span><br><span class="line">assert(s[l] == &apos;\0&apos;);</span><br><span class="line">assert(strlen(s) &lt;= l);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>You can call lua_tolstring with NULL as its third argument if you do not need the length. Better yet, you can use the macro lua_tostring, which simply calls lua_tolstring with a NULL third argument.</p>
</blockquote>
<p><em>Listing 25.2. Dumping the stack:</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stackDump</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> top = lua_gettop(L); <span class="comment">/* depth of the stack */</span> </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=top;i++)&#123; <span class="comment">/*repeatforeachlevel*/</span></span><br><span class="line">        <span class="keyword">int</span> t = lua_type(L, i);</span><br><span class="line">        <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">            <span class="keyword">case</span> LUA_TSTRING: &#123;  <span class="comment">/* strings */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"'%s'"</span>, lua_tostring(L, i));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> LUA_TBOOLEAN: &#123;  <span class="comment">/* booleans */</span></span><br><span class="line">                <span class="built_in">printf</span>(lua_toboolean(L, i) ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> LUA_TNUMBER: &#123;  <span class="comment">/* numbers */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%g"</span>, lua_tonumber(L, i));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">default</span>: &#123;  <span class="comment">/* other values */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, lua_typename(L, t));</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  "</span>);  <span class="comment">/* put a separator */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);  <span class="comment">/* end the listing */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>To illustrate the use of these functions, Listing 25.2 presents a useful helper function that dumps the entire content of the stack. This function traverses the stack from bottom to top, printing each element according to its type. It prints strings between quotes; for numbers it uses a ‘%g’ format; for other values (tables, functions, etc.), it prints only their types. (lua_typename converts a type code to a type name.)</p>
</blockquote>
<h4 id="Other-stack-operations"><a href="#Other-stack-operations" class="headerlink" title="Other stack operations"></a>Other stack operations</h4><blockquote>
<p>Besides the previous functions, which interchange values between C and the stack, the API offers also the following operations for generic stack manipula- tion:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">lua_gettop</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_settop</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushvalue</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_remove</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_insert</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_replace</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_copy</span><span class="params">(lua_State *L, <span class="keyword">int</span> fromidx, <span class="keyword">int</span> toidx)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Function lua_gettop returns the number of elements in the stack, which is also the index of the top element. Function lua_settop sets the top (that is, the number of elements in the stack) to a specific value. If the previous top was higher than the new one, the function discards the extra top values.</p>
</blockquote>
<blockquote>
<p>Otherwise, it pushes nils on the stack to get the given size. As a particular case, lua_settop(L,0) empties the stack. You can also use negative indices with lua_settop. Using this facility, the API offers the following macro, which pops n elements from the stack:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lua_pop(L,n)  lua_settop(L, -(n) - 1)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The lua_pushvalue function pushes on the stack a copy of the element at the given index; lua_remove removes the element at the given index, shifting down all elements on top of this position to fill in the gap; lua_insert moves the top element into the given position, shifting up all elements on top of this position to open space; lua_replace pops a value from the top and sets it as the value of the given index, without moving anything; finally, lua_copy copies the value at one index to another, leaving the original untouched. Notice that the following operations have no effect on a non-empty stack:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lua_settop(L, <span class="number">-1</span>);  <span class="comment">/* set top to its current value */</span></span><br><span class="line">lua_insert(L, <span class="number">-1</span>);  <span class="comment">/* move top element to the top */</span></span><br><span class="line">lua_copy(L, x, x);  <span class="comment">/* copy an element to its own position */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The program in Listing 25.3 uses stackDump (defined in Listing 25.2) to illustrate these stack operations.</p>
</blockquote>
<h3 id="25-3-Error-Handling-with-the-C-API"><a href="#25-3-Error-Handling-with-the-C-API" class="headerlink" title="25.3 Error Handling with the C API"></a>25.3 Error Handling with the C API</h3><blockquote>
<p>All structures in Lua are dynamic: they grow as needed, and eventually shrink again when possible. This means that the possibility of a memory-allocation failure is pervasive in Lua. Almost any operation can face this eventuality. Moreover, many operations can raise other errors; for instance, an access to a global variable can trigger an __index metamethod and that metamethod may throw an error. Finally, operations that allocate memory eventually trigger the garbage collector, which may invoke finalizers, which can throw errors too. In fewer words, the vast majority of functions in the Lua API can result in errors.<br>Instead of using error codes for each operation in its API, Lua uses exceptions to signal errors. Unlike C++ or Java, the C language does not offer an exception handling mechanism. To circumvent this difficulty, <strong>Lua uses the setjmp facility from C, which results in a mechanism similar to exception handling</strong>. Therefore, most API functions can throw an error (that is, call longjmp) instead of return- ing.<br>When we write library code (that is, C functions to be called from Lua), the use of long jumps is almost as convenient as a real exception-handling facility, because Lua catches any occasional error. When we write application code (that is, C code that calls Lua), however, we must provide a way to catch those errors.</p>
</blockquote>
<h4 id="Error-handling-in-application-code"><a href="#Error-handling-in-application-code" class="headerlink" title="Error handling in application code"></a>Error handling in application code</h4><blockquote>
<p>When your application calls functions in the Lua API, it is exposed to errors. As we just discussed, Lua usually signals these errors through long jumps. However, if there is no corresponding setjmp, the interpreter cannot do the jump. <strong>In that case, any error in the API causes Lua to call a panic function and, if that function returns, exit the application.</strong> You can set your own panic function with the lua_atpanic function, but there is not much that such a function can do.<br>To properly handle errors in your application code, you must call your code through Lua, so that it can set an appropriate context to catch errors (<strong>that is, it runs your code in the context of a setjmp</strong>). In the same way we can run Lua code in protected mode using pcall, we can run C code using lua_pcall. More specifically, we pack the C code in a function and call that function through Lua, using lua_pcall. (We will see the details of how to call C functions from Lua in Chapter 27.) With this setting, your C code will run in protected mode. Even in case of memory-allocation failure, lua_pcall returns a proper error code, leaving the interpreter in a consistent state.</p>
</blockquote>
<h4 id="￼￼Error-handling-in-library-code"><a href="#￼￼Error-handling-in-library-code" class="headerlink" title="￼￼Error handling in library code"></a>￼￼Error handling in library code</h4><blockquote>
<p>Lua is a safe language. This means that no matter what you write in Lua, no matter how wrong it is, you can always understand the behavior of a program in terms of Lua itself. Moreover, errors are detected and explained in terms of Lua, too. You can contrast that with C, where the behavior of many wrong programs can be explained only in terms of the underlying hardware (e.g., error positions are given as instruction addresses).<br>Whenever you add new C functions to Lua, you can break its safety. For instance, a function like poke, which stores an arbitrary byte at an arbitrary memory address, can cause all sorts of memory corruption. You must strive to ensure that your add-ons are safe to Lua and provide good error handling.<br>As we discussed earlier, C programs have to set their error handling through lua_pcall. When you write library functions for Lua, however, usually they do not need to handle errors. Errors thrown by a library function will be caught either by a pcall in Lua or by a lua_pcall in the application code. So, whenever a function in a C library detects an error, it can simply call lua_error (or better yet luaL_error, which formats the error message and then calls lua_error). The lua_error function clears whatever needs to be cleared in Lua and jumps back to the protected call that originated that execution, passing along the error message.</p>
</blockquote>
<h4 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h4><blockquote>
<p>Exercise 25.1: Compile and run the simple stand-alone interpreter (Listing 25.1).<br>Exercise 25.2: Assume the stack is empty. What will be its contents after the following sequence of calls?</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lua_pushnumber(L, <span class="number">3.5</span>);</span><br><span class="line">lua_pushstring(L, <span class="string">"hello"</span>);</span><br><span class="line">lua_pushnil(L);</span><br><span class="line">lua_pushvalue(L, <span class="number">-2</span>);</span><br><span class="line">lua_remove(L, <span class="number">1</span>);</span><br><span class="line">lua_insert(L, <span class="number">-2</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Exercise 25.3: Use the simple stand-alone interpreter (Listing 25.1) and the stackDump function (Listing 25.2) to check your answer to the previous exercise.</p>
</blockquote>
<p>一类是非保护模式的接口(如lua_pushstring)，这些接口里面出现的异常全部交给lua自身的PANIC函数进行处理；</p>
<p>另一类是保护模式的接口(如lua_pcall)，这些接口中出现的异常可以人为地抛出来，让外层的程序显示catch到，把异常交给外层的程序处理。</p>
<ol>
<li>lua_pcall</li>
<li>lua_call  lua_error  lua_atpantic</li>
</ol>
<p>最好使用lua_pcall，如果使用lua_call则:</p>
<ol>
<li>若无对应setjmp,则panic，默认exit()，用户可以定义自己的panic;</li>
<li>lua_call也可以有对应setjmp,但是不保证所有的问题都可以longjmp。</li>
</ol>

      
    </div>

    

    
      
    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/27/programming_in_lua/Chapter 28 - Techniques for Writing C Functions/" rel="next" title="Chapter 28 - Techniques for Writing C Functions">
                <i class="fa fa-chevron-left"></i> Chapter 28 - Techniques for Writing C Functions
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/27/programming_in_lua/Chapter 26 - Extending Your Application/" rel="prev" title>
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
  <p class="site-author-name" itemprop="name">binnnliu</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>


  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    

    

    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>













          
          
        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#25-1-A-First-Example"><span class="nav-number">1.</span> <span class="nav-text">25.1  A First Example</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-2-The-Stack"><span class="nav-number">2.</span> <span class="nav-text">25.2 The Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Pushing-elements"><span class="nav-number">2.1.</span> <span class="nav-text">Pushing elements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Querying-elements"><span class="nav-number">2.2.</span> <span class="nav-text">Querying elements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Other-stack-operations"><span class="nav-number">2.3.</span> <span class="nav-text">Other stack operations</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-3-Error-Handling-with-the-C-API"><span class="nav-number">3.</span> <span class="nav-text">25.3 Error Handling with the C API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Error-handling-in-application-code"><span class="nav-number">3.1.</span> <span class="nav-text">Error handling in application code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#￼￼Error-handling-in-library-code"><span class="nav-number">3.2.</span> <span class="nav-text">￼￼Error handling in library code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercises"><span class="nav-number">3.3.</span> <span class="nav-text">Exercises</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">binnnliu</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    

  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
















  
  









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  























<script>
// GET RESPONSIVE HEIGHT PASSED FROM IFRAME

window.addEventListener("message", function(e) {
  var data = e.data;
  if ((typeof data === 'string') && (data.indexOf('ciu_embed') > -1)) {
    var featureID = data.split(':')[1];
    var height = data.split(':')[2];
    $(`iframe[data-feature=${featureID}]`).height(parseInt(height) + 30);
  }
}, false);
</script>








  

</body>
</html>
