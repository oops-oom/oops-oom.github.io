<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">






<link rel="stylesheet" href="/css/main.css?v=7.2.0">






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">








<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="Both the official API and the auxiliary library provide several mechanisms to help writing C functions. In this chapter, we cover the mechanisms for array manipulation, for string manipulation, and f">
<meta property="og:type" content="article">
<meta property="og:title" content="Chapter 28 - Techniques for Writing C Functions">
<meta property="og:url" content="http://yoursite.com/2019/07/27/programming_in_lua/Chapter 28 - Techniques for Writing C Functions/index.html">
<meta property="og:site_name" content="Know Why">
<meta property="og:description" content="Both the official API and the auxiliary library provide several mechanisms to help writing C functions. In this chapter, we cover the mechanisms for array manipulation, for string manipulation, and f">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-07-27T15:14:54.442Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 28 - Techniques for Writing C Functions">
<meta name="twitter:description" content="Both the official API and the auxiliary library provide several mechanisms to help writing C functions. In this chapter, we cover the mechanisms for array manipulation, for string manipulation, and f">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/07/27/programming_in_lua/Chapter 28 - Techniques for Writing C Functions/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>Chapter 28 - Techniques for Writing C Functions | Know Why</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Know Why</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/programming_in_lua/Chapter 28 - Techniques for Writing C Functions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binnnliu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Know Why">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Chapter 28 - Techniques for Writing C Functions

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-27 23:14:54" itemprop="dateCreated datePublished" datetime="2019-07-27T23:14:54+08:00">2019-07-27</time>
            </span>
          

          

          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>Both the official API and the auxiliary library provide several mechanisms to help writing C functions. In this chapter, we cover the mechanisms for array manipulation, for string manipulation, and for storing Lua values in C.</p>
</blockquote>
<h3 id="28-1-Array-Manipulation"><a href="#28-1-Array-Manipulation" class="headerlink" title="28.1 Array Manipulation"></a>28.1 Array Manipulation</h3><blockquote>
<p>“Array”, in Lua, is just a name for a table used in a specific way. We can manipulate arrays using the same functions we use to manipulate tables, namely lua_settable and lua_gettable. However, the API provides special functions for array manipulation. One reason for these extra functions is performance: frequently we have an array-access operation inside the inner loop of an algorithm (e.g., sorting), so that any performance gain in this operation can have a big impact on the overall performance of the algorithm. Another reason is con- venience: like string keys, integer keys are common enough to deserve special treatment.<br>The API provides two functions for array manipulation:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_rawgeti</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_rawseti</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index, <span class="keyword">int</span> key)</span></span>;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>The description of lua_rawgeti and lua_rawseti is a little confusing, as it involves two indices: index refers to where the table is in the stack; key refers to where the element is in the table. The call lua_rawgeti(L,t,key) is equivalent to the following sequence when t is positive (otherwise, you must compensate for the new item in the stack):</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lua_pushnumber(L, key);</span><br><span class="line">lua_rawget(L, t);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The call lua_rawseti(L,t,key) (again for t positive) is equivalent to this sequence:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lua_pushnumber(L, key);</span><br><span class="line">lua_insert(L, <span class="number">-2</span>);  <span class="comment">/* put 'key' below previous value */</span></span><br><span class="line">lua_rawset(L, t);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note that both functions use raw operations. They are faster and, anyway, tables used as arrays seldom use metamethods.</p>
</blockquote>
<p><em>Listing 28.1. The map function in C:</em> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">l_map</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">    <span class="comment">/* 1st argument must be a table (t) */</span></span><br><span class="line">    luaL_checktype(L, <span class="number">1</span>, LUA_TTABLE);</span><br><span class="line">    <span class="comment">/* 2nd argument must be a function (f) */</span></span><br><span class="line">    luaL_checktype(L, <span class="number">2</span>, LUA_TFUNCTION);</span><br><span class="line">    n = luaL_len(L, <span class="number">1</span>);  <span class="comment">/* get size of table */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        lua_pushvalue(L, <span class="number">2</span>);   <span class="comment">/* push f */</span></span><br><span class="line">        lua_rawgeti(L, <span class="number">1</span>, i);  <span class="comment">/* push t[i] */</span></span><br><span class="line">        lua_call(L, <span class="number">1</span>, <span class="number">1</span>);     <span class="comment">/* call f(t[i]) */</span></span><br><span class="line">        lua_rawseti(L, <span class="number">1</span>, i);  <span class="comment">/* t[i] = result */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* no results */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于数组中的所有值调用函数进行处理</p>
<blockquote>
<p>As a concrete example of the use of these functions, Listing 28.1 implements the map function: it applies a given function to all elements of an array, replacing each element by the result of the call. This example also introduces three new functions: luaL_checktype, luaL_len, and lua_pcall.<br>The luaL_checktype function (from lauxlib.h) ensures that a given argument has a given type; otherwise, it raises an error.<br>The primitive lua_len (not used in the example) is equivalent to the ‘#’ operator. Because of metamethods, this operator may result in any kind of object, not only numbers; therefore, lua_len returns its result in the stack. The luaL_len function (the one used in the example, from the auxiliary library) raises an error if the length is not a number; otherwise, it returns the length as a C integer.<br>The lua_call function does an unprotected call. It is similar to lua_pcall, but it propagates errors, instead of returning an error code. When you are writing the main code in an application, you should not use lua_call, because you want to catch any errors. When you are writing functions, however, it is usually a good idea to use lua_call; if there is an error, just leave it to someone that cares about it.</p>
</blockquote>
<p>lua_len的结果有可能是非整数；所以结果被被压栈；<br>主函数中建议使用lua_pcall，其他函数定义中可以使用lua_call，如果出错，可交给外出lua_pcall处理。</p>
<h3 id="28-2-String-Manipulation"><a href="#28-2-String-Manipulation" class="headerlink" title="28.2 String Manipulation"></a>28.2 String Manipulation</h3><blockquote>
<p>When a C function receives a string argument from Lua, there are only two rules that it must observe: <strong>not to pop the string from the stack while accessing it and never to modify the string</strong>.<br>Things get more demanding when a C function needs to create a string to return to Lua. Now, it is up to the C code to take care of buffer alloca- tion/deallocation, buffer overflows, and the like. Nevertheless, the Lua API pro- vides some functions to help with these tasks.<br>The standard API provides support for two of the most basic string opera- tions: substring extraction and string concatenation. To extract a substring, re- member that the basic operation lua_pushlstring gets the string length as an extra argument. Therefore, if you want to pass to Lua a substring of a string s ranging from position i to j (inclusive), all you have to do is this:<br>     lua_pushlstring(L, s + i, j - i + 1);<br>As an example, suppose you want a function that splits a string according to a given separator (a single character) and returns a table with the sub- strings. For instance, the call split(“hi:ho:there”,”:”) should return the ta- ble {“hi”,”ho”,”there”}. Listing 28.2 presents a simple implementation for this function. It needs no extra buffers and puts no constraints on the size of the strings it can handle. Lua takes care of all buffer needs.<br>To concatenate strings, Lua provides a specific function in its API, called lua_concat. It is equivalent to the concatenation operator .. in Lua: it converts numbers to strings and triggers metamethods when necessary. Moreover, it can concatenate more than two strings at once. The call lua_concat(L,n) will concatenate (and pop) the n values at the top of the stack, pushing the result on the top.<br>Another helpful function is lua_pushfstring:<br>const char *lua_pushfstring (lua_State *L, const char *fmt, …);<br>It is somewhat similar to the C function sprintf, in that it creates a string ac- cording to a format string and some extra arguments. Unlike sprintf, however, you do not need to provide a buffer. Lua dynamically creates the string for you, as large as it needs to be. The function pushes the resulting string on the stack and returns a pointer to it. You do not have to worry about buffer overflows.</p>
</blockquote>
<p>Listing 28.2. Splitting a string:<br>   static int l_split (lua_State <em>L) {<br>     const char *s = luaL_checkstring(L, 1);  /</em> subject <em>/<br>     const char *sep = luaL_checkstring(L, 2);  /</em> separator <em>/<br>     const char *e;<br>     int i = 1;<br>     lua_newtable(L);  /</em> result table <em>/<br>     /</em> repeat for each separator <em>/<br>     while ((e = strchr(s, *sep)) != NULL) {<br>lua_pushlstring(L, s, e-s); /</em> push substring <em>/ lua_rawseti(L, -2, i++); /</em> insert it in table <em>/ s=e+1; /*skipseparator</em>/<br>}<br>     /* insert last substring <em>/<br>     lua_pushstring(L, s);<br>     lua_rawseti(L, -2, i);<br>     return 1;  /</em> return the table <em>/<br>   }<br>Currently, this function accepts only the following directives:1<br>It accepts no modifiers, such as width or precision.<br>Both lua_concat and lua_pushfstring are useful when we want to concate-<br>nate only a few strings. However, if we need to concatenate many strings (or characters) together, a one-by-one approach can be quite inefficient, as we saw in Section 11.6. Instead, we can use the buffer facility provided by the auxiliary library.<br>In its simpler usage, the buffer facility works with two functions: one gives you a buffer of any size where you can write your string; the other converts the contents of the buffer into a Lua string.2 Listing 28.3 illustrates those functions with the implementation of the string.upper function, right from the source file lstrlib.c. The first step for using a buffer from the auxiliary<br>Listing 28.3. The string.upper function:<br>   static int str_upper (lua_State *L) {<br>     size_t l;<br>     size_t i;<br>     luaL_Buffer b;<br>     const char *s = luaL_checklstring(L, 1, &amp;l);<br>     char *p = luaL_buffinitsize(L, &amp;b, l);<br>     for (i = 0; i &lt; l; i++)<br>       p[i] = toupper(uchar(s[i]));<br>     luaL_pushresultsize(&amp;b, l);<br>     return 1;<br>}<br>library is to declare a variable with type luaL_Buffer. The next step is to call luaL_buffinitsize to get a pointer for a buffer with the given size; you can then use this buffer freely to create your string. The last step is to call luaL_pushresultsize to convert the buffer contents into a new Lua string on the top of the stack. The size in this second call is the final size of the string. (Often, as in our example, this size is equal to the size of the buffer, but it can be smaller. If you do not know the exact size of the resulting string, but have an upper bound, you can conservatively allocate a larger size.)<br>Note that function luaL_pushresultsize does not get a Lua state as its first argument. After the initialization, a buffer keeps a reference to the state, so we do not need to pass it when calling other functions that manipulate buffers.<br>We can also use these auxlib buffers without knowing any upper bound for the size of the final result. Listing 28.4 shows a simplified implementation for the table.concat function. In this function, we first call luaL_buffinit to initialize the buffer. We then add elements to the buffer one by one, in this example using luaL_addvalue. Finally, luaL_pushresult flushes the buffer and leaves the final string at the top of the stack.<br>The auxiliary library offers several functions to add things to a buffer: func- tion luaL_addvalue adds a Lua string that is on the top of the stack; function luaL_addlstring adds strings with an explicit length; function luaL_addstring adds zero-terminated strings; and function luaL_addchar adds single characters. These functions have the following prototypes:<br>     void luaL_buffinit   (lua_State *L, luaL_Buffer *B);<br>     void luaL_addvalue   (luaL_Buffer *B);<br>     void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);<br>     void luaL_addstring  (luaL_Buffer *B, const char *s);<br>     void luaL_addchar    (luaL_Buffer *B, char c);<br>     void luaL_pushresult (luaL_Buffer *B);<br>When you use the auxlib buffer, you have to worry about one detail. After you initialize a buffer, it keeps some intermediate results in the Lua stack.<br>￼Listing 28.4. A simplified implementation for table.concat:<br>   static int tconcat (lua_State *L) {<br>     luaL_Buffer b;<br>     int i, n;<br>     luaL_checktype(L, 1, LUA_TTABLE);<br>     n = luaL_len(L, 1);<br>     luaL_buffinit(L, &amp;b);<br>     for (i = 1; i &lt;= n; i++) {<br>       lua_rawgeti(L, 1, i);  /</em> get string from table <em>/<br>       luaL_addvalue(b);  /</em> add it to the buffer */<br>     }<br>     luaL_pushresult(&amp;b);<br>     return 1;<br>}<br>Therefore, you cannot assume that the stack top will remain where it was before you started using the buffer. Moreover, although you can use the stack for other tasks while using a buffer, the push/pop count for these uses must be balanced every time you access the buffer. The exception to this rule is function luaL_addvalue, that assumes that the string to be added to the buffer was pushed on the top of the stack.</p>
<h3 id="28-3-Storing-State-in-C-Functions"><a href="#28-3-Storing-State-in-C-Functions" class="headerlink" title="28.3 Storing State in C Functions"></a>28.3 Storing State in C Functions</h3><blockquote>
<p>Frequently, C functions need to keep some non-local data, that is, data that outlive their invocation. In C, we typically use global (extern) or static variables for this need. When you are programming library functions for Lua, however, global and static variables are not a good approach. First, you cannot store a generic Lua value in a C variable. Second, a library that uses such variables will not work with multiple Lua states.<br>A Lua function has two basic places to store non-local data: global variables and non-local variables. The C API also offers two basic places to store non-local data: the registry and upvalues.<br>The registry is a global table that <strong>can be accessed only by C code</strong>. Typically, you use it to store data to be <strong>shared among several modules</strong>. If you need to store data private to a module or to a single function, you should use upvalues.</p>
</blockquote>
<p>非local data：upvalue和registry</p>
<h4 id="The-registry"><a href="#The-registry" class="headerlink" title="The registry"></a>The registry</h4><blockquote>
<p>The registry is always located at a <strong>pseudo-index</strong>, whose value is defined by <strong>LUA_REGISTRYINDEX</strong>. A pseudo-index is like an index into the stack, except that its associated value is not in the stack. Most functions in the Lua API that accept indices as arguments also accept pseudo-indices—the exceptions being those functions that manipulate the stack itself, such as lua_remove and lua_insert. For instance, to get a value stored with key “Key” in the registry, you can use the following call:<br> <code>lua_getfield(L, LUA_REGISTRYINDEX, &quot;Key&quot;)</code><br>The registry is a regular Lua table. As such, you can index it with any Lua value but nil. However, <strong>because all C modules share the same registry, you must choose with care what values you use as keys, to avoid collisions</strong>. String keys are particularly useful when you want to allow other independent libraries to access your data, because all they need to know is the key name. For those keys, there is no bulletproof method of choosing names, but there are some good practices, such as avoiding common names and prefixing your names with the library name or something like it. (Prefixes like lua or lualib are not good choices.)</p>
</blockquote>
<p>registry key如何避免冲突；<br>number类型的key留给引用系统；</p>
<blockquote>
<p>You should <strong>never use numbers as keys in the registry</strong>, because such keys are reserved for the <strong>reference system</strong>. This system comprises a couple of functions in the auxiliary library that allow you to store values in a table without worrying about how to create unique names. Function <strong>luaL_ref</strong> creates new references:<br> <code>int r = luaL_ref(L, LUA_REGISTRYINDEX);</code><br>The previous call pops a value from the stack, stores it into the registry with a fresh integer key, and returns this key. We call this key a reference.<br>As the name implies, we use references mainly when we need to store a reference to a Lua value inside a C structure. As we have seen, we should never store pointers to Lua strings outside the C function that retrieved them. Moreover, Lua does not even offer pointers to other objects, such as tables or functions. So, we cannot refer to Lua objects through pointers. Instead, when we need such pointers, we <strong>create a reference and store it in C</strong>.<br>To push the value associated with a reference r onto the stack, we simply write this:<br><code>lua_rawgeti(L, LUA_REGISTRYINDEX, r);</code><br>Finally, to release both the value and the reference, we call luaL_unref:<br> <code>luaL_unref(L, LUA_REGISTRYINDEX, r);</code><br>After this call, a new call to luaL_ref may return again this reference.<br>The reference system treats nil as a special case. Whenever we call luaL_ref for a nil value, it does not create a new reference, but instead returns the<br>constant reference <strong>LUA_REFNIL</strong>. The next call has no effect: luaL_unref(L, LUA_REGISTRYINDEX, LUA_REFNIL);<br>The next one pushes a nil, as expected:<br><code>lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_REFNIL);</code><br>The reference system also defines the constant <strong>LUA_NOREF</strong>, which is an integer different from any valid reference. <strong>It is useful to mark references as invalid.</strong><br>Another bulletproof method to create keys into the registry is to use as key the address of a static variable in your code: the C link editor ensures that this key is unique among all libraries. To use this option, you need the function lua_pushlightuserdata, which pushes on the Lua stack a value representing a C pointer. The following code shows how to store and retrieve a string from the registry using this method:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* variable with a unique address */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> Key = <span class="string">'k'</span>;</span><br><span class="line"><span class="comment">/* store a string */</span></span><br><span class="line">lua_pushlightuserdata(L, (<span class="keyword">void</span> *)&amp;Key);  <span class="comment">/* push address */</span></span><br><span class="line">lua_pushstring(L, myStr);  <span class="comment">/* push value */</span></span><br><span class="line">lua_settable(L, LUA_REGISTRYINDEX);  <span class="comment">/* registry[&amp;Key] = myStr */</span></span><br><span class="line"><span class="comment">/* retrieve a string */</span></span><br><span class="line">lua_pushlightuserdata(L, (<span class="keyword">void</span> *)&amp;Key);  <span class="comment">/* push address */</span></span><br><span class="line">lua_gettable(L, LUA_REGISTRYINDEX);  <span class="comment">/* retrieve value */</span></span><br><span class="line">myStr = lua_tostring(L, <span class="number">-1</span>);  <span class="comment">/* convert to string */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>We will discuss light userdata in more detail in Section 29.5.<br>To simplify the use of variable addresses as unique keys, Lua 5.2 introduced two new functions: <strong>lua_rawgetp and lua_rawsetp</strong>. They are similar to lua_rawgeti-lua_rawseti but, instead of integers, they use C pointers (trans- lated to light userdata) as keys. With them, we can write the previous code like<br>this:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> Key = <span class="string">'k'</span>;</span><br><span class="line"><span class="comment">/* store a string */</span></span><br><span class="line">lua_pushstring(L, myStr);</span><br><span class="line">lua_rawsetp(L, LUA_REGISTRYINDEX, (<span class="keyword">void</span> *)&amp;Key);</span><br><span class="line"><span class="comment">/* retrieve a string */</span></span><br><span class="line">lua_rawgetp(L, LUA_REGISTRYINDEX, (<span class="keyword">void</span> *)&amp;Key);</span><br><span class="line">myStr = lua_tostring(L, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Both functions use raw accesses. As the registry usually does not have a meta- table, a raw access has the same behavior of a regular access, and it is slightly more efficient.</p>
</blockquote>
<h4 id="Upvalues"><a href="#Upvalues" class="headerlink" title="Upvalues"></a>Upvalues</h4><blockquote>
<p>While the registry offers global variables, the upvalue mechanism implements <strong>an equivalent of C static variables</strong> that are visible only inside a particular<br>function. Every time you create a new C function in Lua, you can associate with it any number of upvalues; each upvalue can hold a single Lua value. Later, when the function is called, it has free access to any of its upvalues, using pseudo-indices.</p>
</blockquote>
<p>A function only has an upvalue on _ENV if it references a global variable. </p>
<blockquote>
<p>We call this association of a C function with its upvalues a closure. A C closure is a C approximation to a Lua closure. In particular, you can create different closures using the same function code, but with different upvalues.<br>To see a simple example, let us create a newCounter function in C. This function is a factory: it returns a new counter function each time it is called. Although all counters share the same C code, each one keeps its own independent counter. The factory function is like this:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">counter</span> <span class="params">(lua_State *L)</span></span>;  <span class="comment">/* forward declaration */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newCounter</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    lua_pushinteger(L, <span class="number">0</span>);</span><br><span class="line">    lua_pushcclosure(L, &amp;counter, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The key function here is lua_pushcclosure, which creates a new closure. Its second argument is the base function (counter, in the example) and the third is the number of upvalues (1, in the example). Before creating a new closure, we must push on the stack the initial values for its upvalues. In our example, we push the number 0 as the initial value for the single upvalue. As expected, lua_pushcclosure leaves the new closure on the stack, so the closure is ready to be returned as the result of newCounter.<br>Now, let us see the definition of counter:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">counter</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = lua_tointeger(L, lua_upvalueindex(<span class="number">1</span>));</span><br><span class="line">    lua_pushinteger(L, ++val);  <span class="comment">/* new value */</span></span><br><span class="line">    lua_pushvalue(L, <span class="number">-1</span>);  <span class="comment">/* duplicate it */</span></span><br><span class="line">    lua_replace(L, lua_upvalueindex(<span class="number">1</span>));  <span class="comment">/* update upvalue */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* return new value */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Here, the key element is macro <strong>lua_upvalueindex</strong>, which produces the pseudo-index of an upvalue. In particular, the expression lua_upvalueindex(1) results in the pseudo-index of the first upvalue of the running function. Again, this pseudo-index is like any stack index, except that it does not live in the stack. So, the call to lua_tointeger retrieves the current value of the first (and only) upvalue as a number. Then, function counter pushes the new value ++val, makes a copy of it, and uses one of the copies to replace the upvalue’s value. Finally, it returns the other copy as its return value.</p>
</blockquote>
<blockquote>
<p>As a more advanced example, we will implement tuples using upvalues. A tuple is a kind of constant record with anonymous fields; you can retrieve a specific field with a numerical index, or you can retrieve all fields at once. In our implementation, we represent tuples as functions that store their values in their upvalues. When called with a numerical argument, the function returns that specific field. When called without arguments, it returns all its fields. The following code illustrates the use of tuples:</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = tuple.new(<span class="number">10</span>, <span class="string">"hi"</span>, &#123;&#125;, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(x(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(x())</span><br><span class="line"><span class="comment">--&gt; 10</span></span><br><span class="line"><span class="comment">--&gt; hi</span></span><br><span class="line"><span class="comment">--&gt; 10  hi  table: 0x8087878  3</span></span><br></pre></td></tr></table></figure>

<p><em>Listing 28.5. An implementation of tuples:</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">t_tuple</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op = luaL_optint(L, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">0</span>) &#123;  <span class="comment">/* no arguments? */</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">/* push each valid upvalue onto the stack */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; !lua_isnone(L, lua_upvalueindex(i)); i++)</span><br><span class="line">            lua_pushvalue(L, lua_upvalueindex(i));</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span>;  <span class="comment">/* number of values in the stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* get field 'op' */</span></span><br><span class="line">        luaL_argcheck(L, <span class="number">0</span> &lt; op, <span class="number">1</span>, <span class="string">"index out of range"</span>);</span><br><span class="line">        <span class="keyword">if</span> (lua_isnone(L, lua_upvalueindex(op)))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* no such field */</span></span><br><span class="line">        lua_pushvalue(L, lua_upvalueindex(op));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">t_new</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    lua_pushcclosure(L, t_tuple, lua_gettop(L));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">tuplelib</span> [] = &#123;</span></span><br><span class="line">    &#123;<span class="string">"new"</span>, t_new&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaopen_tuple</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    luaL_newlib(L, tuplelib);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>In C, we represent all tuples by the same function t_tuple, presented in Listing 28.5. Because we can call a tuple with or without a numeric argument, t_tuple uses luaL_optint to get its optional argument. The luaL_optint function is similar to luaL_checkint, but it does not complain if the argument is absent; instead, it returns a given default value (0, in the example).<br>When we index a non-existent upvalue, the result is a pseudo-value whose type is LUA_TNONE. (When we access a stack index above the current top, we also get a pseudo-value with this type LUA_TNONE.) So, our t_tuple function uses lua_isnone to test whether it has a given upvalue. However, we should never call lua_upvalueindex with a negative index, so we must check for this condition when the user provides the index. The luaL_argcheck function checks any given condition, raising an error if necessary.<br>The function to create tuples, t_new (also in Listing 28.5), is trivial: because its arguments are already in the stack, it just has to call lua_pushcclosure to create a closure of t_tuple with all its arguments as upvalues. Finally, array tuplelib and function luaopen_tuple (also in Listing 28.5) are the standard code to create a library tuple with that single function new.</p>
</blockquote>
<h4 id="Shared-upvalues"><a href="#Shared-upvalues" class="headerlink" title="Shared upvalues"></a>Shared upvalues</h4><blockquote>
<p>Frequently, we need to share some values or variables among all functions in a library. Although we can use the registry for that task, we can also use upvalues. <strong>Unlike Lua closures, C closures cannot share upvalues.</strong> Each closure has its own independent upvalues. However, we can set the upvalues of different functions to refer to a common table, so that this table becomes a common environment where all those functions can share data.<br>Lua 5.2 offers a function that eases the task of sharing an upvalue among all functions of a library. We have been opening C libraries with luaL_newlib. Lua implements this function as the following macro:</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define luaL_newlib(L,l)  \</span><br><span class="line">     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>The macro luaL_newlibtable just creates a new table for the library. (We could use lua_newtable as well, but this macro uses lua_createtable to create a table with a preallocated size optimal for the number of functions in the given library.)</p>
<blockquote>
<p>Function luaL_setfuncs adds the functions in the list l to that new table, which is on the top of the stack.<br>The third parameter to luaL_setfuncs is what we are interested here. <strong>It tells how many upvalues the new functions in the library will have.</strong> The initial value for these upvalues should be in the stack, as happens with lua_pushcclosure. Therefore, to create a library where all functions share a common table as their single upvalue, we can use the following code:</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* <span class="built_in">create</span> library <span class="built_in">table</span> (<span class="string">'lib'</span> is its list of functions) */</span><br><span class="line">luaL_newlibtable(L, lib);</span><br><span class="line">/* <span class="built_in">create</span> shared upvalue */</span><br><span class="line">lua_newtable(L);</span><br><span class="line">/* add functions <span class="keyword">in</span> list <span class="string">'lib'</span> to the new library, sharing</span><br><span class="line">   previous <span class="built_in">table</span> as upvalue */</span><br><span class="line">luaL_setfuncs(L, lib, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The last call also removes the shared table from the stack, leaving there only the new library.</p>
</blockquote>
<h4 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h4><blockquote>
<p>Exercise 28.1: Implement a filter function in C. It should receive a list and a predicate and return a new list with all elements from the given list that satisfy the predicate:</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = filter(&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">-4</span>, <span class="number">5</span>&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span> <span class="keyword">return</span> x &lt; <span class="number">5</span> <span class="keyword">end</span>)</span><br><span class="line"><span class="comment">-- t = &#123;1, 3, -4&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>(A predicate is just a function that tests some condition, returning a boolean.)<br>Exercise 28.2: Modify function l_split (from Listing 28.2) so that it can work with strings containing zeros. (Among other changes, it should use memchr instead of strchr.)<br>Exercise28.3: Reimplementthetransliteratefunction(Exercise21.3)inC.<br>Exercise 28.4: Implement a library with a modification of transliterate so that the transliteration table is not given as an argument, but instead is kept by the library. Your library should offer the following functions:</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lib.settrans (<span class="built_in">table</span>)</span><br><span class="line">lib.gettrans ()</span><br><span class="line">lib.tranliterate(s)</span><br><span class="line"><span class="comment">-- set the transliteration table</span></span><br><span class="line"><span class="comment">-- get the transliteration table</span></span><br><span class="line"><span class="comment">-- transliterate 's' according to the current table</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Use the registry to keep the transliteration table.<br>Exercise 28.5: Repeat the previous exercise using an upvalue to keep the transliteration table.<br>Exercise28.6: Doyouthinkitisagooddesigntokeepthetransliterationtable as part of the state of the library, instead of being a parameter to tranliterate?</p>
</blockquote>

      
    </div>

    

    
      
    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/27/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/27/programming_in_lua/Chapter 25 - An Overview of the C API/" rel="prev" title="Chapter 25 - An Overview of the C API">
                Chapter 25 - An Overview of the C API <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
  <p class="site-author-name" itemprop="name">binnnliu</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>


  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    

    

    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>













          
          
        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#28-1-Array-Manipulation"><span class="nav-number">1.</span> <span class="nav-text">28.1 Array Manipulation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-2-String-Manipulation"><span class="nav-number">2.</span> <span class="nav-text">28.2 String Manipulation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-3-Storing-State-in-C-Functions"><span class="nav-number">3.</span> <span class="nav-text">28.3 Storing State in C Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#The-registry"><span class="nav-number">3.1.</span> <span class="nav-text">The registry</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Upvalues"><span class="nav-number">3.2.</span> <span class="nav-text">Upvalues</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Shared-upvalues"><span class="nav-number">3.3.</span> <span class="nav-text">Shared upvalues</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercises"><span class="nav-number">3.4.</span> <span class="nav-text">Exercises</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">binnnliu</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    

  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
















  
  









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  























<script>
// GET RESPONSIVE HEIGHT PASSED FROM IFRAME

window.addEventListener("message", function(e) {
  var data = e.data;
  if ((typeof data === 'string') && (data.indexOf('ciu_embed') > -1)) {
    var featureID = data.split(':')[1];
    var height = data.split(':')[2];
    $(`iframe[data-feature=${featureID}]`).height(parseInt(height) + 30);
  }
}, false);
</script>








  

</body>
</html>
