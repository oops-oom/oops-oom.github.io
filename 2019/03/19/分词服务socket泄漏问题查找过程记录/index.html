<!DOCTYPE html>
<html lang="zh-tw">
  <head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="线上响应超时问题分析"><meta name="keywords" content="golang, 网络编程, 知其所以然"><link rel="alternate" href="/default" title="知其所以然"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="http://yoursite.com/2019/03/19/分词服务socket泄漏问题查找过程记录/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>线上响应超时问题分析 - 知其所以然</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">知其所以然</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首頁
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">歸檔
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">知其所以然</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首頁
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            歸檔
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">线上响应超时问题分析
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-19
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目錄</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#线上响应超时问题分析"><span class="toc-text">线上响应超时问题分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#现象"><span class="toc-text">现象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#日志"><span class="toc-text">日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络问题"><span class="toc-text">网络问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务运行情况"><span class="toc-text">服务运行情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#too-many-open-files的影响"><span class="toc-text">too many open files的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一些延伸"><span class="toc-text">一些延伸</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket泄漏"><span class="toc-text">socket泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><h1 id="线上响应超时问题分析"><a href="#线上响应超时问题分析" class="headerlink" title="线上响应超时问题分析"></a>线上响应超时问题分析</h1><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>调用分词服务的服务发现超时并告警，查看分词服务被调耗时发现一切正常；本机手动请求发现确实存在响应慢的问题。</p>
<p>重启后发现响应正常，重启线上服务，确保线上服务正常；并保留一台进行观察。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>日志中只一些业务错误的记录，未发现明显导致问题的错误；</p>
<h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><p>由于分词服务被调耗时正常，根据经验首先是怀疑网络问题：</p>
<p>因为分词服务响应包较小，所以被调的时间是接收到请求的时间到把响应写到tcp发送缓冲区的时间,不包括网络时间。(查看Linux默认tcp写缓冲区为16K，如果响应大于16K，那么被调会包含部分网络时间，但不是全部)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#min default max, SO_SNDBUF and SO_RCVBUF 设置的最大值由net.core.wmem_max定义</span><br><span class="line">#使用SO_SNDBUF和SO_RCVBUF设置后，实际申请时会翻倍</span><br><span class="line">#为最大值net.core.wmem_max时也会翻倍</span><br><span class="line">net.ipv4.tcp_mem = 377637	503519	755274</span><br><span class="line">net.ipv4.tcp_rmem = 4096	87380	6291456</span><br><span class="line">net.ipv4.tcp_wmem = 4096	16384	4194304</span><br><span class="line"></span><br><span class="line">net.core.rmem_default = 262144  </span><br><span class="line">net.core.wmem_default = 262144 </span><br><span class="line"></span><br><span class="line"># SO_SNDBUF and SO_RCVBUF </span><br><span class="line">net.core.rmem_max = 16777216  </span><br><span class="line">net.core.wmem_max = 16777216</span><br></pre></td></tr></table></figure>

<p>查看主备调监控服务，发现网络流量没有较大的波动；<strong>暂时排除网络问题</strong>。</p>
<h2 id="服务运行情况"><a href="#服务运行情况" class="headerlink" title="服务运行情况"></a>服务运行情况</h2><p>top查看服务负载正常。没有头绪，但是运气很好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p `pidof httpseg`</span><br></pre></td></tr></table></figure>

<p>打开文件数确实挺多，很多如下条目：</p>
<p><code>httpseg 17125 webdev  149u     sock        0,6      0t0 2289696420 protocol: TCP</code></p>
<p>此处开始怀疑是不是打开的文件数超过了服务的限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/`pidof httpseg`/fdinfo|wc -l</span><br><span class="line">1024</span><br><span class="line">cat /proc/`pidof httpseg`/limits</span><br><span class="line">Limit                     Soft Limit           Hard Limit           Units</span><br><span class="line">Max cpu time              unlimited            unlimited            seconds</span><br><span class="line">Max file size             unlimited            unlimited            bytes</span><br><span class="line">Max data size             unlimited            unlimited            bytes</span><br><span class="line">Max stack size            8388608              unlimited            bytes</span><br><span class="line">Max core file size        2048                 unlimited            bytes</span><br><span class="line">Max resident set          unlimited            unlimited            bytes</span><br><span class="line">Max processes             63034                63034                processes</span><br><span class="line">Max open files            1024                 1000000              files</span><br><span class="line">Max locked memory         65536                65536                bytes</span><br><span class="line">Max address space         unlimited            unlimited            bytes</span><br><span class="line">Max file locks            unlimited            unlimited            locks</span><br><span class="line">Max pending signals       63034                63034                signals</span><br><span class="line">Max msgqueue size         819200               819200               bytes</span><br><span class="line">Max nice priority         0                    0</span><br><span class="line">Max realtime priority     0                    0</span><br><span class="line">Max realtime timeout      unlimited            unlimited            us</span><br></pre></td></tr></table></figure>

<p>问题：too many open files </p>
<p>此处有个严重的失误：</p>
<p><strong>按理说一开始就能发现问题，但是查看日志时只看了业务日志，没有看stdout,stderr的日志，而且直到重启完所有有问题的机器，也没有看这些日志；更悲剧的是这些日志使用的是覆盖的方式，而非追加的方式，导致重启后日志全没了。</strong></p>
<p>也是在于对golang http的服务相关代码不够了解导致。</p>
<h2 id="too-many-open-files的影响"><a href="#too-many-open-files的影响" class="headerlink" title="too many open files的影响"></a>too many open files的影响</h2><p>代码细节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">	rw, e := l.Accept()</span><br><span class="line">	if e != nil &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-srv.getDoneChan():</span><br><span class="line">			return ErrServerClosed</span><br><span class="line">		default:</span><br><span class="line">		&#125;</span><br><span class="line">		if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">			if tempDelay == 0 &#123;</span><br><span class="line">				tempDelay = 5 * time.Millisecond</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				tempDelay *= 2</span><br><span class="line">			&#125;</span><br><span class="line">			if max := 1 * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">				tempDelay = max</span><br><span class="line">			&#125;</span><br><span class="line">			srv.logf(&quot;http: Accept error: %v; retrying in %v&quot;, e, tempDelay)</span><br><span class="line">			time.Sleep(tempDelay)</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		return e</span><br><span class="line">	&#125;</span><br><span class="line">	tempDelay = 0</span><br><span class="line">	c := srv.newConn(rw)</span><br><span class="line">	c.setState(c.rwc, StateNew) // before Serve can return</span><br><span class="line">	go c.serve(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://oops-oom.github.io/img/accept_error.png" alt="日志"></p>
<p><strong>打开文件数超过程序限制会导致accept失败，accept失败后会循环重试，这里的log默认是输出的stdout的。</strong></p>
<h3 id="一些延伸"><a href="#一些延伸" class="headerlink" title="一些延伸"></a>一些延伸</h3><p>accept失败会导致accept队列中的连接不能被及时取出，accept队列满了怎么办？</p>
<p><strong>三次握手产生的：sync队列和accept队列</strong></p>
<p><strong>accept是取得accept队列中的Establish状态的连接</strong></p>
<p><strong>accept-queue满了怎么办</strong></p>
<p>accept队列长度： <code>min(/proc/sys/net/core/somaxconn, backlog)</code></p>
<blockquote>
<p>The  backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.  If a connection request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED or, if the underlying protocol supports retransmission, the request may be ignored so that a later reattempt at connection succeeds.</p>
</blockquote>
<p>默认情况下，即<code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>为0时，服务端会忽略客户端响应的ack(连接会停留在syn队列)，等待超时，服务端重新发送sync+ack给客户端(<code>net.ipv4.tcp_synack_retries</code>)；<br><code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>为1时，accept-queue满，服务端会响应rst。</p>
<p><strong>syn队列满了怎么办</strong><br><code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code></p>
<p>若SYN队列满，则会直接丢弃请求，即新的SYN网络分组会被丢弃；客户端则会超时重传syn.</p>
<blockquote>
<p>比如syn floods 攻击就是针对半连接队列的，攻击方不停地建连接，但是建连接的时候只做第一步，第二步中攻击方收到server的syn+ack后故意扔掉什么也不做，导致server上这个队列满其它正常请求无法进来</p>
</blockquote>
<p>此处没有考虑tcp_syncookies的影响</p>
<p><strong>命令查看队列满了的丢包现象</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -s | egrep <span class="string">"listen|LISTEN"</span> </span><br><span class="line">19219 <span class="built_in">times</span> the listen queue of a socket overflowed</span><br><span class="line">19234 SYNs to LISTEN sockets dropped</span><br></pre></td></tr></table></figure>

<p><img src="https://oops-oom.github.io/img/tcp.jpg" alt="[图片来自莿鸟栖草堂](https://www.cnxct.com/something-about-phpfpm-s-backlog/)"></p>
<p>too  many open files导致accept失败会重试导致响应耗时增加，同时accept失败会导致accept队列中的连接不能被及时取出，accept队列会慢；</p>
<p>accept队列满了，server端会丢弃ack，超时后server重发syn + ack，导致耗时增加；</p>
<p>syn队列慢了，server端会丢弃syn，超时后clienth会重发syn，导致耗时增加。</p>
<p>以上原因导致请求分词服务响应会慢，但是由于被调时间是从连接完成开始计算的，所以从被调上是看不出问题的。</p>
<h2 id="socket泄漏"><a href="#socket泄漏" class="headerlink" title="socket泄漏"></a>socket泄漏</h2><p>由于服务是简单的golang提供http服务，调用分词库，所以第一时间就怀疑是分词库的问题。</p>
<blockquote>
<p>业务背景：分词库会请求鉴权服务进行鉴权，鉴权失败的话，分词库是不能正常使用的。</p>
</blockquote>
<p>但是问题是，没有分词服务的源代码。如何定位？</p>
<p>最小化服务，排除干扰，只调用分词库进行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace ./demo</span><br></pre></td></tr></table></figure>

<p><img src="https://oops-oom.github.io/img/strace01.png" alt="strace输出"></p>
<p>分析发现，确实创建了两个socket，但是只close了一个。</p>
<p>这里是采用非阻塞的方式发起连接，此处connect时，返回EINPROGRESS；</p>
<p>直接看man 2 connect:</p>
<blockquote>
<p>EINPROGRESS<br>The socket is non-blocking and the connection cannot be completed immediately. It is possible to select(2) or poll(2) for completion by selecting the socket for writing.After select(2) indicates writability, use getsockopt(2) to read the SO_ERROR option at level SOL_SOCKET to determine whether connect() completed successfully (SO_ERROR is zero) or unsuccessfully (SO_ERROR is one of the usual error codes listed here, explaining the reason for the failure).</p>
</blockquote>
<p>服务将对应的fd放入poll侦听可写状态，侦听到可写后调用getsockopt判断是连接成功还是失败。</p>
<p>第一个连接获得的SO_ERROR为110，查看errno 110 为Connection timed out;</p>
<p>问题就在这个地方，连接失败了，但是没有关闭socket！</p>
<p>第二个连接获得的SO_ERROR为0，说明连接正常，后续也正常关闭了连接。(问题已反馈给词库开发同学)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>线上服务qps 100+的服务使用了默认的limit，不应该；</p>
</li>
<li><p>日志不应该重启就丢了，太low；</p>
</li>
<li><p>定位问题的手段：</p>
<p>日志:  没有查看标准错误日志,里面有明确的错误原因；</p>
<p>网络状况: 可以看到因为accept队列满而丢包的情况；</p>
<p>明明可以靠日志或或者现象找到问题，偏偏靠运气才找到。</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://jm.taobao.org/2017/05/25/525-1/" target="_blank" rel="noopener">关于TCP 半连接队列和全连接队列</a></p>
<p><a href="https://www.taohui.pub/" target="_blank" rel="noopener">高性能网络编程</a></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://yoursite.com">oops-oom</a>
    </p>
    <p class="copyright-item">
      <span>原文鏈結: </span>
      <a href="http://yoursite.com/2019/03/19/分词服务socket泄漏问题查找过程记录/">http://yoursite.com/2019/03/19/分词服务socket泄漏问题查找过程记录/</a>
    </p>
    <p class="copyright-item">
      <span>授權: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/golang/">golang</a>
            <a href="/tags/网络编程/">网络编程</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2019/07/28/golang中的for range语义的理解/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">golang中的for range语义的理解</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2017/03/19/对nginx $request_time的一些理解/">
        <span class="next-text nav-default">对于nginx $request_time的一些理解</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/ahonn" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 技術提供
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主題 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">oops-oom</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
