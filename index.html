<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">






<link rel="stylesheet" href="/css/main.css?v=7.2.0">






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">








<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Know Why">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Know Why">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Know Why">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>Know Why</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Know Why</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
        

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/programming_in_lua/Chapter 26 - Extending Your Application/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binnnliu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Know Why">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/27/programming_in_lua/Chapter 26 - Extending Your Application/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-27 23:14:54" itemprop="dateCreated datePublished" datetime="2019-07-27T23:14:54+08:00">2019-07-27</time>
            </span>
          

          

          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="noopener">StackEdit</a>.</p>
</blockquote>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>

    
        

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/programming_in_lua/Chapter 25 - An Overview of the C API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binnnliu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Know Why">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/27/programming_in_lua/Chapter 25 - An Overview of the C API/" class="post-title-link" itemprop="url">Chapter 25 - An Overview of the C API</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-27 23:14:54" itemprop="dateCreated datePublished" datetime="2019-07-27T23:14:54+08:00">2019-07-27</time>
            </span>
          

          

          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Lua is an embedded language. This means that Lua is not a stand-alone pack- age, but a library that we can link with other applications to incorporate Lua facilities into them.<br>You may be wondering: <strong>if Lua is not a stand-alone program, how come we have been using Lua stand-alone through the whole book until now</strong>? The solution to this puzzle is the Lua interpreter (the executable lua). This interpreter is a tiny application (with less than five hundred lines of code) that uses the Lua library to implement the stand-alone interpreter. This program handles the interface with the user, taking her files and strings to feed them to the Lua library, which does the bulk of the work (such as actually running Lua code).</p>
</blockquote>
<p>lua是一门嵌入式的语言。</p>
<blockquote>
<p>This ability to be used as a library to extend an application is what makes Lua an <strong>extension language</strong>. At the same time, a program that uses Lua can register new functions in the Lua environment; such functions are implemented in C (or another language), so that they can add facilities that cannot be written directly in Lua. This is what makes Lua an <strong>extensible language</strong>.<br>These two views of Lua (as an extension language and as an extensible language) correspond to two kinds of interaction between C and Lua. In the first kind, C has the control and Lua is the library. The C code in this kind of interaction is what we call <strong>application code</strong>. In the second kind, Lua has the control and C is the library. Here, the C code is called <strong>library code</strong>. <strong>Both application code and library code use the same API to communicate with Lua, the so-called C API</strong>.<br>The C API is the set of functions that allow C code to interact with Lua. It comprises functions to read and write Lua global variables, to call Lua functions,o run pieces of Lua code, to register C functions so that they can later be called by Lua code, and so on. Virtually anything that Lua code can do can also be done by C code through the C API.</p>
</blockquote>
<p>extension language vs extensible language<br>application code      vs library code</p>
<blockquote>
<p><strong>The C API follows the modus operandi of C</strong>, which is quite different from the modus operandi of Lua. When programming in C, we must care about type checking, error recovery, memory-allocation errors, and several other sources of complexity. Most functions in the API do not check the correctness of their arguments; it is your responsibility to make sure that the arguments are valid before calling a function. If you make mistakes, you can get a “segmentation fault” error or something similar, instead of a well-behaved error message. Moreover, <strong>the API emphasizes flexibility and simplicity</strong>, sometimes at the cost of ease of use. Common tasks may involve several API calls. This may be boring, but it gives you full control over all details.</p>
</blockquote>
<p>C API遵循C的规则，与lua差异较大。<br>更重要的是，lua强调简单和灵活，甚至以易用性作为代价。</p>
<blockquote>
<p>As its title says, the goal of this chapter is to give an overview of what is involved when you use Lua from C. Do not bother understanding all the details of what is going on now. Later we will fill in the details. Nevertheless, do not forget that you always can find more details about specific functions in the Lua reference manual. Moreover, you can find several examples of the use of the API in the Lua distribution itself. <strong>The Lua stand-alone interpreter (lua.c) provides examples of application code, while the standard libraries (lmathlib.c, lstrlib.c, etc.) provide examples of library code.</strong><br>From now on, we are wearing a C programmers’ hat. When I talk about “you”, I mean you when programming in C, or you impersonated by the C code you write.</p>
</blockquote>
<p>本章仅仅是讲述一个模型。</p>
<blockquote>
<p>A major component in the communication between Lua and C is an omnipresent <strong>virtual stack</strong>. Almost all API calls operate on values on this stack. All data exchange from Lua to C and from C to Lua occurs through this stack. Moreover, you can use the stack to keep intermediate results too. The stack helps to solve two impedance mismatches between Lua and C: the first is caused by Lua being garbage collected, whereas C requires explicit deallocation; the second results from the shock between dynamic typing in Lua versus the static typing of C. We will discuss the stack in more detail in Section 25.2.</p>
</blockquote>
<p>无处不在的virtual stack负责：C与Lua交换数据；保存中间结果；<br>解决了lua与C交互的难题</p>
<ul>
<li>内存管理（GC）</li>
<li>静态类型和动态类型</li>
</ul>
<h3 id="25-1-A-First-Example"><a href="#25-1-A-First-Example" class="headerlink" title="25.1  A First Example"></a>25.1  A First Example</h3><blockquote>
<p>We will start this overview with a simple example of an application program: a stand-alone Lua interpreter. We can write a primitive stand-alone interpreter as in Listing 25.1. The header file lua.h defines the basic functions provided by Lua. It includes functions to create a new Lua environment, to invoke Lua functions (such as lua_pcall), to read and write global variables in the Lua environment, to register new functions to be called by Lua, and so on. Everything defined in lua.h has a lua_ prefix.</p>
</blockquote>
<p><em>Listing 25.1. A simple stand-alone Lua interpreter:</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lua.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lauxlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lualib.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    lua_State *L = luaL_newstate();</span><br><span class="line">    luaL_openlibs(L);        <span class="comment">/* opens the standard libraries */</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(buff, <span class="keyword">sizeof</span>(buff), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        error = luaL_loadstring(L, buff) || lua_pcall(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">            lua_pop(L, <span class="number">1</span>);  <span class="comment">/* pop error message from the stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_close(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The header file lauxlib.h defines the functions provided by the auxiliary library (auxlib). All its definitions start with luaL_ (e.g., luaL_loadstring). The auxiliary library uses the basic API provided by lua.h to provide a higher abstraction level, in particular with abstractions used by the standard libraries. The basic API strives for economy and orthogonality, whereas the auxiliary library strives for practicality for common tasks. Of course, it is very easy for your program to create other abstractions that it needs, too. Keep in mind that the auxiliary library has no access to the internals of Lua. It does its entire job through the official basic API. Whatever it does, your program can do.</p>
</blockquote>
<p>lua.h vs lauxlib.h 区别：</p>
<ol>
<li>lua_ vs luaL_；</li>
<li>lauxlib.h 提供更高层次的函数，基于lua.h。</li>
</ol>
<blockquote>
<p>The Lua library defines no global variables at all. It keeps all its state in the dynamic structure lua_State; <strong>all functions inside Lua receive a pointer to this structure as an argument.</strong> This implementation makes Lua reentrant and ready to be used in multithreaded code.</p>
</blockquote>
<p>lua library没有定义全局变量，所有的状态被保存在lua_State中；lua中所有的函数接收一个指向lua_State的参数。</p>
<blockquote>
<p>As its name implies, the luaL_newstate function creates a new Lua state. When luaL_newstate creates a fresh state, its environment contains no predefined functions, not even print. To keep Lua small, all standard libraries are provided as separate packages, so that you do not have to use them if you do not need to. The header file lualib.h defines functions to open the libraries. Function luaL_openlibs opens all standard libraries.</p>
</blockquote>
<p>刚创建好的Lua state是没有任何预定义的函数的，包括print。<br>为了使lua保持简单，所有的标准库都作为单独的包；我们可以选择性的载入我们需要的库。<br>lualib.h定义了库操作函数，luaL_openlibs加载所有标准库；</p>
<blockquote>
<p>After creating a state and <strong>populating</strong> it with the standard libraries, it is time to interpret the user input. For each line the user enters, the program first calls luaL_loadstring to compile the code. If there are no errors, the call returns zero and pushes the resulting function on the stack. (Remember that we will discuss this “magic” stack in detail in the next section.) Then the program calls lua_pcall, which pops the function from the stack and runs it in protected mode. Like luaL_loadstring, lua_pcall returns zero if there are no errors. In case of an error, both functions push an error message on the stack; we get this message with lua_tostring and, after printing it, we remove it from the stack with lua_pop.</p>
</blockquote>
<p>处理顺序</p>
<ol>
<li>lua_State *L = luaL_newstate(); </li>
<li>luaL_openlibs(L) </li>
<li>luaL_loadstring()  =&gt; compile code</li>
<li>lua_pcall()</li>
</ol>
<p>lua_pcall和luaL_loadstring如果没有错误，则返回0，并把运行结果压栈；如果有错误，会把错误信息压栈；</p>
<blockquote>
<p>Notice that, in case of error, this program simply prints the error message to the standard error stream. Real error handling can be quite complex in C, and how to do it depends on the nature of your application. <strong>The Lua core never writes anything directly to any output stream; it signals errors by returning error messages.</strong> Each application can handle these messages in a way most appropriate for its needs. To simplify our discussions, we will assume for now a simple error handler like the following one, which prints an error message, closes the Lua state, and exits from the whole application:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list argp;</span><br><span class="line">    va_start(argp, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, argp);</span><br><span class="line">    va_end(argp);</span><br><span class="line">    lua_close(L);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Later we will discuss more about error handling in the application code. Because you can compile Lua both as C and as C++ code, lua.h does not include this typical adjustment code that is present in several other C libraries:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>If you have compiled Lua as C code (the most common case) and are using it in C++, you can include lua.hpp instead of lua.h. It is defined as follows:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lua.h"</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何兼容C++，这里的extern是告诉C++编译器按照C的的规则翻译响应的函数名称。</p>
<h3 id="25-2-The-Stack"><a href="#25-2-The-Stack" class="headerlink" title="25.2 The Stack"></a>25.2 The Stack</h3><blockquote>
<p>We face two problems when trying to exchange values between Lua and C: the mismatch between a dynamic and a static type system and the mismatch between automatic and manual memory management.</p>
</blockquote>
<p>交互的两大困难： GC和动静类型；</p>
<blockquote>
<p>In Lua, when we write a[k]=v, both k and v can have several different types; even a can have different types, due to metatables. If we want to offer this operation in C, however, any given settable function must have a fixed type. We would need dozens of different functions for this single operation (one function for each combination of types<br>for the three arguments).</p>
</blockquote>
<p>lua动态类型，如果需要C支持lua的这些操作，就需要任何函数支持多种类型。</p>
<p>We could solve this problem by declaring some kind of union type in C— let us call it <strong>lua_Value</strong> — that could represent all Lua values. Then, we could declare settable as</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void lua_settable (lua_Value a, lua_Value k, lua_Value v);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This solution has two drawbacks. First, it can be difficult to map such a complex type to other languages; we designed Lua to interface easily not only with C/C++, but also with Java, Fortran, C#, and the like. Second, Lua does garbage collection: if we keep a Lua table in a C variable, the Lua engine has no way to know about this use; it may (wrongly) assume that this table is garbage and collect it.</p>
</blockquote>
<p>两个原因不采用lua_Value:</p>
<ol>
<li>与其他语言交互困难；</li>
<li>GC不易控制；</li>
</ol>
<blockquote>
<p>Therefore, the Lua API does not define anything like a lua_Value type. Instead, it uses an abstract stack to exchange values between Lua and C. Each slot in this stack can hold any Lua value. Whenever you want to ask for a value from Lua (such as the value of a global variable), you call Lua, which pushes the required value on the stack. Whenever you want to pass a value to Lua, you first push the value on the stack, and then you call Lua (which will pop the value). We still need a different function to push each C type on the stack and a different function to get each C type from the stack, but we avoid the combinatorial explosion. <strong>Moreover, because this stack lives inside Lua, the garbage collector knows which values C is using.</strong><br>Nearly all functions in the API use the stack. As we saw in our first example, luaL_loadstring leaves its result on the stack (either the compiled chunk or an error message); lua_pcall gets the function to be called from the stack and leaves any occasional error message there too.</p>
</blockquote>
<p>lua几乎所有的操作api都会操作vitual stack。</p>
<blockquote>
<p>Lua manipulates this stack in a strict LIFO discipline (Last In, First Out). When you call Lua, it changes only the top part of the stack. Your C code has more freedom; specifically, it can inspect any element inside the stack and even insert and delete elements in any arbitrary position.</p>
</blockquote>
<h4 id="Pushing-elements"><a href="#Pushing-elements" class="headerlink" title="Pushing elements"></a>Pushing elements</h4><blockquote>
<p>The API has one push function for each C type that can be represented in Lua: lua_pushnil for the constant nil, lua_pushboolean for booleans (integers, in C), lua_pushnumber for doubles, lua_pushinteger for integers, lua_pushunsigned for unsigned integers, lua_pushlstring for arbitrary strings (a pointer to char plus a length), and lua_pushstring for zero-terminated strings:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushnil</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushboolean</span><span class="params">(lua_State *L, <span class="keyword">int</span> <span class="keyword">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushnumber</span><span class="params">(lua_State *L, lua_Number n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushinteger</span><span class="params">(lua_State *L, lua_Integer n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushunsigned</span><span class="params">(lua_State *L, lua_Unsigned n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushlstring</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushstring</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>There are also functions to push C functions and userdata values on the stack; we will discuss them later.<br>The type lua_Number is the numeric type in Lua. It is a double by default, but some installations can change it to a float or even a long integer, to accommodate Lua to restricted machines. The type lua_Integer is a signed integral type large enough to store the size of large strings. Usually, it is defined as the ptrdiff_t type. The type lua_Unsigned is a 32-bit unsigned integral type in C; it is used by the bitwise library and related functions.</p>
</blockquote>
<blockquote>
<p><strong>Strings in Lua are not zero-terminated</strong>; they can contain arbitrary binary data. In consequence, they must rely on an explicit length. The basic function to push a string onto the stack is <code>lua_pushlstring</code>, which requires an ex- plicit length as an argument. For zero-terminated strings, you can use also <code>lua_pushstring</code>, which uses strlen to supply the string length. Lua never keeps pointers to external strings (or to any other external object except C functions, which are always static). For any string that it has to keep, Lua either makes an internal copy or reuses one. Therefore, you can free or modify your buffer as soon as these functions return.<br>Whenever you push an element onto the stack, <strong>it is your responsibility to ensure that the stack has space for it</strong>. Remember, you are a C programmer now; Lua will not spoil you. When Lua starts and any time that Lua calls C, the stack has at least 20 free slots. (The header file lua.h defines this constant as LUA_MINSTACK.) This space is more than enough for most common uses, so usually we do not even think about it. However, some tasks need more stack space, in particular if you have a loop pushing elements into the stack. In those cases, you may want to call lua_checkstack, which checks whether the stack has enough space for your needs:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lua_checkstack</span> <span class="params">(lua_State *L, <span class="keyword">int</span> sz)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="Querying-elements"><a href="#Querying-elements" class="headerlink" title="Querying elements"></a>Querying elements</h4><blockquote>
<p>To refer to elements in the stack, the API uses indices. The first element pushed on the stack has index 1, the next one has index 2, and so on until the top. We can also access elements using the top of the stack as our reference, using negative indices. In this case, ￼ 1 refers to the element at the top (that is, the last<br>element pushed), 2 to the previous element, and so on. For instance, the call lua_tostring(L,-1) returns the value at the top of the stack as a string. As we will see, there are several occasions when it is natural to index the stack from the bottom (that is, with positive indices), and several other occasions when the natural way is to use negative indices.</p>
</blockquote>
<p>stack index</p>
<blockquote>
<p>To check whether an element has a specific type, the API offers a family of functions lua_is *, where the * can be any Lua type. So, there are lua_isnumber, lua_isstring, lua_istable, and the like. All these functions have the same prototype:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lua_is* (lua_State *L, <span class="keyword">int</span> index);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Actually, lua_isnumber does not check <strong>whether the value has that specific type, but whether the value can be converted to that type</strong>; lua_isstring is similar: in particular, any number satisfies lua_isstring.<br>There is also a function lua_type, which returns the type of an element in the stack. Each type is represented by a constant defined in the header file lua.h: LUA_TNIL, LUA_TBOOLEAN, LUA_TNUMBER, LUA_TSTRING, LUA_TTABLE, LUA_TTHREAD, LUA_TUSERDATA, and LUA_TFUNCTION. We use this function mainly in conjunction with a switch statement. It is also useful when we need to check for strings and numbers without coercions.<br>To get a value from the stack, there are the lua_to* functions:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>          <span class="title">lua_toboolean</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>  *<span class="title">lua_tolstring</span><span class="params">(lua_State *L, <span class="keyword">int</span> index,  <span class="keyword">size_t</span> *len)</span></span>;</span><br><span class="line"><span class="function">lua_Number   <span class="title">lua_tonumber</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">lua_Integer  <span class="title">lua_tointeger</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">lua_Unsigned <span class="title">lua_tounsigned</span><span class="params">(lua_State *L, <span class="keyword">int</span> idx)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The lua_toboolean converts any Lua value to a C boolean (0 or 1), following the Lua rules for conditions: the values nil and false are false; any other value is true.<br><strong>It is OK to call any of the lua_to* functions even when the given element does not have an appropriate type.</strong> Function lua_toboolean works for any type; lua_tolstring returns NULL for non-string values. The numeric functions, however, have no way to signal a wrong type, so they simply return zero. Usually you would need to call lua_isnumber to check the type, but Lua 5.2 introduced the following new functions:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">lua_Number   <span class="title">lua_tonumberx</span><span class="params">(lua_State *L, <span class="keyword">int</span> idx, <span class="keyword">int</span> *isnum)</span></span>;</span><br><span class="line"><span class="function">lua_Integer  <span class="title">lua_tointegerx</span><span class="params">(lua_State *L, <span class="keyword">int</span> idx, <span class="keyword">int</span> *isnum)</span></span>;</span><br><span class="line"><span class="function">lua_Unsigned <span class="title">lua_tounsignedx</span><span class="params">(lua_State *L, <span class="keyword">int</span> idx, <span class="keyword">int</span> *isnum)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The out parameter isnum returns a boolean that indicates whether the Lua value is a number. (You can call those functions with NULL as the last parameter, if you do not need that value. The old lua_to* functions are now implemented as macros using this facility.)</p>
</blockquote>
<p>我们可以调用任何lua_to*系列函数，即使类型不匹配。如果超出正常index范围呢？</p>
<blockquote>
<p>The lua_tolstring function returns a pointer to an internal copy of the string and stores the string’s length in the position given by len. <strong>You cannot change this internal copy</strong> (there is a const there to remind you). Lua ensures that this pointer is valid as long as the corresponding string value is in the stack. When a C function called by Lua returns, Lua clears its stack; therefore, as a rule, you should never store pointers to Lua strings outside the function that got them.<br><strong>Any string that lua_tolstring returns always has an extra zero at its end, but it can have other zeros inside it.</strong> The size returned through the third argument, len, is the real string’s length. In particular, assuming that the value at the top of the stack is a string, the following assertions are always valid:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_t l;</span><br><span class="line">const char *s = lua_tolstring(L, -1, &amp;l);   /* any Lua string */</span><br><span class="line">assert(s[l] == &apos;\0&apos;);</span><br><span class="line">assert(strlen(s) &lt;= l);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>You can call lua_tolstring with NULL as its third argument if you do not need the length. Better yet, you can use the macro lua_tostring, which simply calls lua_tolstring with a NULL third argument.</p>
</blockquote>
<p><em>Listing 25.2. Dumping the stack:</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stackDump</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> top = lua_gettop(L); <span class="comment">/* depth of the stack */</span> </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=top;i++)&#123; <span class="comment">/*repeatforeachlevel*/</span></span><br><span class="line">        <span class="keyword">int</span> t = lua_type(L, i);</span><br><span class="line">        <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">            <span class="keyword">case</span> LUA_TSTRING: &#123;  <span class="comment">/* strings */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"'%s'"</span>, lua_tostring(L, i));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> LUA_TBOOLEAN: &#123;  <span class="comment">/* booleans */</span></span><br><span class="line">                <span class="built_in">printf</span>(lua_toboolean(L, i) ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> LUA_TNUMBER: &#123;  <span class="comment">/* numbers */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%g"</span>, lua_tonumber(L, i));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">default</span>: &#123;  <span class="comment">/* other values */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, lua_typename(L, t));</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  "</span>);  <span class="comment">/* put a separator */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);  <span class="comment">/* end the listing */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>To illustrate the use of these functions, Listing 25.2 presents a useful helper function that dumps the entire content of the stack. This function traverses the stack from bottom to top, printing each element according to its type. It prints strings between quotes; for numbers it uses a ‘%g’ format; for other values (tables, functions, etc.), it prints only their types. (lua_typename converts a type code to a type name.)</p>
</blockquote>
<h4 id="Other-stack-operations"><a href="#Other-stack-operations" class="headerlink" title="Other stack operations"></a>Other stack operations</h4><blockquote>
<p>Besides the previous functions, which interchange values between C and the stack, the API offers also the following operations for generic stack manipula- tion:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">lua_gettop</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_settop</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushvalue</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_remove</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_insert</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_replace</span><span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_copy</span><span class="params">(lua_State *L, <span class="keyword">int</span> fromidx, <span class="keyword">int</span> toidx)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Function lua_gettop returns the number of elements in the stack, which is also the index of the top element. Function lua_settop sets the top (that is, the number of elements in the stack) to a specific value. If the previous top was higher than the new one, the function discards the extra top values.</p>
</blockquote>
<blockquote>
<p>Otherwise, it pushes nils on the stack to get the given size. As a particular case, lua_settop(L,0) empties the stack. You can also use negative indices with lua_settop. Using this facility, the API offers the following macro, which pops n elements from the stack:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lua_pop(L,n)  lua_settop(L, -(n) - 1)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The lua_pushvalue function pushes on the stack a copy of the element at the given index; lua_remove removes the element at the given index, shifting down all elements on top of this position to fill in the gap; lua_insert moves the top element into the given position, shifting up all elements on top of this position to open space; lua_replace pops a value from the top and sets it as the value of the given index, without moving anything; finally, lua_copy copies the value at one index to another, leaving the original untouched. Notice that the following operations have no effect on a non-empty stack:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lua_settop(L, <span class="number">-1</span>);  <span class="comment">/* set top to its current value */</span></span><br><span class="line">lua_insert(L, <span class="number">-1</span>);  <span class="comment">/* move top element to the top */</span></span><br><span class="line">lua_copy(L, x, x);  <span class="comment">/* copy an element to its own position */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The program in Listing 25.3 uses stackDump (defined in Listing 25.2) to illustrate these stack operations.</p>
</blockquote>
<h3 id="25-3-Error-Handling-with-the-C-API"><a href="#25-3-Error-Handling-with-the-C-API" class="headerlink" title="25.3 Error Handling with the C API"></a>25.3 Error Handling with the C API</h3><blockquote>
<p>All structures in Lua are dynamic: they grow as needed, and eventually shrink again when possible. This means that the possibility of a memory-allocation failure is pervasive in Lua. Almost any operation can face this eventuality. Moreover, many operations can raise other errors; for instance, an access to a global variable can trigger an __index metamethod and that metamethod may throw an error. Finally, operations that allocate memory eventually trigger the garbage collector, which may invoke finalizers, which can throw errors too. In fewer words, the vast majority of functions in the Lua API can result in errors.<br>Instead of using error codes for each operation in its API, Lua uses exceptions to signal errors. Unlike C++ or Java, the C language does not offer an exception handling mechanism. To circumvent this difficulty, <strong>Lua uses the setjmp facility from C, which results in a mechanism similar to exception handling</strong>. Therefore, most API functions can throw an error (that is, call longjmp) instead of return- ing.<br>When we write library code (that is, C functions to be called from Lua), the use of long jumps is almost as convenient as a real exception-handling facility, because Lua catches any occasional error. When we write application code (that is, C code that calls Lua), however, we must provide a way to catch those errors.</p>
</blockquote>
<h4 id="Error-handling-in-application-code"><a href="#Error-handling-in-application-code" class="headerlink" title="Error handling in application code"></a>Error handling in application code</h4><blockquote>
<p>When your application calls functions in the Lua API, it is exposed to errors. As we just discussed, Lua usually signals these errors through long jumps. However, if there is no corresponding setjmp, the interpreter cannot do the jump. <strong>In that case, any error in the API causes Lua to call a panic function and, if that function returns, exit the application.</strong> You can set your own panic function with the lua_atpanic function, but there is not much that such a function can do.<br>To properly handle errors in your application code, you must call your code through Lua, so that it can set an appropriate context to catch errors (<strong>that is, it runs your code in the context of a setjmp</strong>). In the same way we can run Lua code in protected mode using pcall, we can run C code using lua_pcall. More specifically, we pack the C code in a function and call that function through Lua, using lua_pcall. (We will see the details of how to call C functions from Lua in Chapter 27.) With this setting, your C code will run in protected mode. Even in case of memory-allocation failure, lua_pcall returns a proper error code, leaving the interpreter in a consistent state.</p>
</blockquote>
<h4 id="￼￼Error-handling-in-library-code"><a href="#￼￼Error-handling-in-library-code" class="headerlink" title="￼￼Error handling in library code"></a>￼￼Error handling in library code</h4><blockquote>
<p>Lua is a safe language. This means that no matter what you write in Lua, no matter how wrong it is, you can always understand the behavior of a program in terms of Lua itself. Moreover, errors are detected and explained in terms of Lua, too. You can contrast that with C, where the behavior of many wrong programs can be explained only in terms of the underlying hardware (e.g., error positions are given as instruction addresses).<br>Whenever you add new C functions to Lua, you can break its safety. For instance, a function like poke, which stores an arbitrary byte at an arbitrary memory address, can cause all sorts of memory corruption. You must strive to ensure that your add-ons are safe to Lua and provide good error handling.<br>As we discussed earlier, C programs have to set their error handling through lua_pcall. When you write library functions for Lua, however, usually they do not need to handle errors. Errors thrown by a library function will be caught either by a pcall in Lua or by a lua_pcall in the application code. So, whenever a function in a C library detects an error, it can simply call lua_error (or better yet luaL_error, which formats the error message and then calls lua_error). The lua_error function clears whatever needs to be cleared in Lua and jumps back to the protected call that originated that execution, passing along the error message.</p>
</blockquote>
<h4 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h4><blockquote>
<p>Exercise 25.1: Compile and run the simple stand-alone interpreter (Listing 25.1).<br>Exercise 25.2: Assume the stack is empty. What will be its contents after the following sequence of calls?</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lua_pushnumber(L, <span class="number">3.5</span>);</span><br><span class="line">lua_pushstring(L, <span class="string">"hello"</span>);</span><br><span class="line">lua_pushnil(L);</span><br><span class="line">lua_pushvalue(L, <span class="number">-2</span>);</span><br><span class="line">lua_remove(L, <span class="number">1</span>);</span><br><span class="line">lua_insert(L, <span class="number">-2</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Exercise 25.3: Use the simple stand-alone interpreter (Listing 25.1) and the stackDump function (Listing 25.2) to check your answer to the previous exercise.</p>
</blockquote>
<p>一类是非保护模式的接口(如lua_pushstring)，这些接口里面出现的异常全部交给lua自身的PANIC函数进行处理；</p>
<p>另一类是保护模式的接口(如lua_pcall)，这些接口中出现的异常可以人为地抛出来，让外层的程序显示catch到，把异常交给外层的程序处理。</p>
<ol>
<li>lua_pcall</li>
<li>lua_call  lua_error  lua_atpantic</li>
</ol>
<p>最好使用lua_pcall，如果使用lua_call则:</p>
<ol>
<li>若无对应setjmp,则panic，默认exit()，用户可以定义自己的panic;</li>
<li>lua_call也可以有对应setjmp,但是不保证所有的问题都可以longjmp。</li>
</ol>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>

    
        

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/programming_in_lua/Chapter 28 - Techniques for Writing C Functions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binnnliu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Know Why">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/27/programming_in_lua/Chapter 28 - Techniques for Writing C Functions/" class="post-title-link" itemprop="url">Chapter 28 - Techniques for Writing C Functions</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-27 23:14:54" itemprop="dateCreated datePublished" datetime="2019-07-27T23:14:54+08:00">2019-07-27</time>
            </span>
          

          

          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Both the official API and the auxiliary library provide several mechanisms to help writing C functions. In this chapter, we cover the mechanisms for array manipulation, for string manipulation, and for storing Lua values in C.</p>
</blockquote>
<h3 id="28-1-Array-Manipulation"><a href="#28-1-Array-Manipulation" class="headerlink" title="28.1 Array Manipulation"></a>28.1 Array Manipulation</h3><blockquote>
<p>“Array”, in Lua, is just a name for a table used in a specific way. We can manipulate arrays using the same functions we use to manipulate tables, namely lua_settable and lua_gettable. However, the API provides special functions for array manipulation. One reason for these extra functions is performance: frequently we have an array-access operation inside the inner loop of an algorithm (e.g., sorting), so that any performance gain in this operation can have a big impact on the overall performance of the algorithm. Another reason is con- venience: like string keys, integer keys are common enough to deserve special treatment.<br>The API provides two functions for array manipulation:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_rawgeti</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_rawseti</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index, <span class="keyword">int</span> key)</span></span>;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>The description of lua_rawgeti and lua_rawseti is a little confusing, as it involves two indices: index refers to where the table is in the stack; key refers to where the element is in the table. The call lua_rawgeti(L,t,key) is equivalent to the following sequence when t is positive (otherwise, you must compensate for the new item in the stack):</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lua_pushnumber(L, key);</span><br><span class="line">lua_rawget(L, t);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The call lua_rawseti(L,t,key) (again for t positive) is equivalent to this sequence:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lua_pushnumber(L, key);</span><br><span class="line">lua_insert(L, <span class="number">-2</span>);  <span class="comment">/* put 'key' below previous value */</span></span><br><span class="line">lua_rawset(L, t);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note that both functions use raw operations. They are faster and, anyway, tables used as arrays seldom use metamethods.</p>
</blockquote>
<p><em>Listing 28.1. The map function in C:</em> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">l_map</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">    <span class="comment">/* 1st argument must be a table (t) */</span></span><br><span class="line">    luaL_checktype(L, <span class="number">1</span>, LUA_TTABLE);</span><br><span class="line">    <span class="comment">/* 2nd argument must be a function (f) */</span></span><br><span class="line">    luaL_checktype(L, <span class="number">2</span>, LUA_TFUNCTION);</span><br><span class="line">    n = luaL_len(L, <span class="number">1</span>);  <span class="comment">/* get size of table */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        lua_pushvalue(L, <span class="number">2</span>);   <span class="comment">/* push f */</span></span><br><span class="line">        lua_rawgeti(L, <span class="number">1</span>, i);  <span class="comment">/* push t[i] */</span></span><br><span class="line">        lua_call(L, <span class="number">1</span>, <span class="number">1</span>);     <span class="comment">/* call f(t[i]) */</span></span><br><span class="line">        lua_rawseti(L, <span class="number">1</span>, i);  <span class="comment">/* t[i] = result */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* no results */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于数组中的所有值调用函数进行处理</p>
<blockquote>
<p>As a concrete example of the use of these functions, Listing 28.1 implements the map function: it applies a given function to all elements of an array, replacing each element by the result of the call. This example also introduces three new functions: luaL_checktype, luaL_len, and lua_pcall.<br>The luaL_checktype function (from lauxlib.h) ensures that a given argument has a given type; otherwise, it raises an error.<br>The primitive lua_len (not used in the example) is equivalent to the ‘#’ operator. Because of metamethods, this operator may result in any kind of object, not only numbers; therefore, lua_len returns its result in the stack. The luaL_len function (the one used in the example, from the auxiliary library) raises an error if the length is not a number; otherwise, it returns the length as a C integer.<br>The lua_call function does an unprotected call. It is similar to lua_pcall, but it propagates errors, instead of returning an error code. When you are writing the main code in an application, you should not use lua_call, because you want to catch any errors. When you are writing functions, however, it is usually a good idea to use lua_call; if there is an error, just leave it to someone that cares about it.</p>
</blockquote>
<p>lua_len的结果有可能是非整数；所以结果被被压栈；<br>主函数中建议使用lua_pcall，其他函数定义中可以使用lua_call，如果出错，可交给外出lua_pcall处理。</p>
<h3 id="28-2-String-Manipulation"><a href="#28-2-String-Manipulation" class="headerlink" title="28.2 String Manipulation"></a>28.2 String Manipulation</h3><blockquote>
<p>When a C function receives a string argument from Lua, there are only two rules that it must observe: <strong>not to pop the string from the stack while accessing it and never to modify the string</strong>.<br>Things get more demanding when a C function needs to create a string to return to Lua. Now, it is up to the C code to take care of buffer alloca- tion/deallocation, buffer overflows, and the like. Nevertheless, the Lua API pro- vides some functions to help with these tasks.<br>The standard API provides support for two of the most basic string opera- tions: substring extraction and string concatenation. To extract a substring, re- member that the basic operation lua_pushlstring gets the string length as an extra argument. Therefore, if you want to pass to Lua a substring of a string s ranging from position i to j (inclusive), all you have to do is this:<br>     lua_pushlstring(L, s + i, j - i + 1);<br>As an example, suppose you want a function that splits a string according to a given separator (a single character) and returns a table with the sub- strings. For instance, the call split(“hi:ho:there”,”:”) should return the ta- ble {“hi”,”ho”,”there”}. Listing 28.2 presents a simple implementation for this function. It needs no extra buffers and puts no constraints on the size of the strings it can handle. Lua takes care of all buffer needs.<br>To concatenate strings, Lua provides a specific function in its API, called lua_concat. It is equivalent to the concatenation operator .. in Lua: it converts numbers to strings and triggers metamethods when necessary. Moreover, it can concatenate more than two strings at once. The call lua_concat(L,n) will concatenate (and pop) the n values at the top of the stack, pushing the result on the top.<br>Another helpful function is lua_pushfstring:<br>const char *lua_pushfstring (lua_State *L, const char *fmt, …);<br>It is somewhat similar to the C function sprintf, in that it creates a string ac- cording to a format string and some extra arguments. Unlike sprintf, however, you do not need to provide a buffer. Lua dynamically creates the string for you, as large as it needs to be. The function pushes the resulting string on the stack and returns a pointer to it. You do not have to worry about buffer overflows.</p>
</blockquote>
<p>Listing 28.2. Splitting a string:<br>   static int l_split (lua_State <em>L) {<br>     const char *s = luaL_checkstring(L, 1);  /</em> subject <em>/<br>     const char *sep = luaL_checkstring(L, 2);  /</em> separator <em>/<br>     const char *e;<br>     int i = 1;<br>     lua_newtable(L);  /</em> result table <em>/<br>     /</em> repeat for each separator <em>/<br>     while ((e = strchr(s, *sep)) != NULL) {<br>lua_pushlstring(L, s, e-s); /</em> push substring <em>/ lua_rawseti(L, -2, i++); /</em> insert it in table <em>/ s=e+1; /*skipseparator</em>/<br>}<br>     /* insert last substring <em>/<br>     lua_pushstring(L, s);<br>     lua_rawseti(L, -2, i);<br>     return 1;  /</em> return the table <em>/<br>   }<br>Currently, this function accepts only the following directives:1<br>It accepts no modifiers, such as width or precision.<br>Both lua_concat and lua_pushfstring are useful when we want to concate-<br>nate only a few strings. However, if we need to concatenate many strings (or characters) together, a one-by-one approach can be quite inefficient, as we saw in Section 11.6. Instead, we can use the buffer facility provided by the auxiliary library.<br>In its simpler usage, the buffer facility works with two functions: one gives you a buffer of any size where you can write your string; the other converts the contents of the buffer into a Lua string.2 Listing 28.3 illustrates those functions with the implementation of the string.upper function, right from the source file lstrlib.c. The first step for using a buffer from the auxiliary<br>Listing 28.3. The string.upper function:<br>   static int str_upper (lua_State *L) {<br>     size_t l;<br>     size_t i;<br>     luaL_Buffer b;<br>     const char *s = luaL_checklstring(L, 1, &amp;l);<br>     char *p = luaL_buffinitsize(L, &amp;b, l);<br>     for (i = 0; i &lt; l; i++)<br>       p[i] = toupper(uchar(s[i]));<br>     luaL_pushresultsize(&amp;b, l);<br>     return 1;<br>}<br>library is to declare a variable with type luaL_Buffer. The next step is to call luaL_buffinitsize to get a pointer for a buffer with the given size; you can then use this buffer freely to create your string. The last step is to call luaL_pushresultsize to convert the buffer contents into a new Lua string on the top of the stack. The size in this second call is the final size of the string. (Often, as in our example, this size is equal to the size of the buffer, but it can be smaller. If you do not know the exact size of the resulting string, but have an upper bound, you can conservatively allocate a larger size.)<br>Note that function luaL_pushresultsize does not get a Lua state as its first argument. After the initialization, a buffer keeps a reference to the state, so we do not need to pass it when calling other functions that manipulate buffers.<br>We can also use these auxlib buffers without knowing any upper bound for the size of the final result. Listing 28.4 shows a simplified implementation for the table.concat function. In this function, we first call luaL_buffinit to initialize the buffer. We then add elements to the buffer one by one, in this example using luaL_addvalue. Finally, luaL_pushresult flushes the buffer and leaves the final string at the top of the stack.<br>The auxiliary library offers several functions to add things to a buffer: func- tion luaL_addvalue adds a Lua string that is on the top of the stack; function luaL_addlstring adds strings with an explicit length; function luaL_addstring adds zero-terminated strings; and function luaL_addchar adds single characters. These functions have the following prototypes:<br>     void luaL_buffinit   (lua_State *L, luaL_Buffer *B);<br>     void luaL_addvalue   (luaL_Buffer *B);<br>     void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);<br>     void luaL_addstring  (luaL_Buffer *B, const char *s);<br>     void luaL_addchar    (luaL_Buffer *B, char c);<br>     void luaL_pushresult (luaL_Buffer *B);<br>When you use the auxlib buffer, you have to worry about one detail. After you initialize a buffer, it keeps some intermediate results in the Lua stack.<br>￼Listing 28.4. A simplified implementation for table.concat:<br>   static int tconcat (lua_State *L) {<br>     luaL_Buffer b;<br>     int i, n;<br>     luaL_checktype(L, 1, LUA_TTABLE);<br>     n = luaL_len(L, 1);<br>     luaL_buffinit(L, &amp;b);<br>     for (i = 1; i &lt;= n; i++) {<br>       lua_rawgeti(L, 1, i);  /</em> get string from table <em>/<br>       luaL_addvalue(b);  /</em> add it to the buffer */<br>     }<br>     luaL_pushresult(&amp;b);<br>     return 1;<br>}<br>Therefore, you cannot assume that the stack top will remain where it was before you started using the buffer. Moreover, although you can use the stack for other tasks while using a buffer, the push/pop count for these uses must be balanced every time you access the buffer. The exception to this rule is function luaL_addvalue, that assumes that the string to be added to the buffer was pushed on the top of the stack.</p>
<h3 id="28-3-Storing-State-in-C-Functions"><a href="#28-3-Storing-State-in-C-Functions" class="headerlink" title="28.3 Storing State in C Functions"></a>28.3 Storing State in C Functions</h3><blockquote>
<p>Frequently, C functions need to keep some non-local data, that is, data that outlive their invocation. In C, we typically use global (extern) or static variables for this need. When you are programming library functions for Lua, however, global and static variables are not a good approach. First, you cannot store a generic Lua value in a C variable. Second, a library that uses such variables will not work with multiple Lua states.<br>A Lua function has two basic places to store non-local data: global variables and non-local variables. The C API also offers two basic places to store non-local data: the registry and upvalues.<br>The registry is a global table that <strong>can be accessed only by C code</strong>. Typically, you use it to store data to be <strong>shared among several modules</strong>. If you need to store data private to a module or to a single function, you should use upvalues.</p>
</blockquote>
<p>非local data：upvalue和registry</p>
<h4 id="The-registry"><a href="#The-registry" class="headerlink" title="The registry"></a>The registry</h4><blockquote>
<p>The registry is always located at a <strong>pseudo-index</strong>, whose value is defined by <strong>LUA_REGISTRYINDEX</strong>. A pseudo-index is like an index into the stack, except that its associated value is not in the stack. Most functions in the Lua API that accept indices as arguments also accept pseudo-indices—the exceptions being those functions that manipulate the stack itself, such as lua_remove and lua_insert. For instance, to get a value stored with key “Key” in the registry, you can use the following call:<br> <code>lua_getfield(L, LUA_REGISTRYINDEX, &quot;Key&quot;)</code><br>The registry is a regular Lua table. As such, you can index it with any Lua value but nil. However, <strong>because all C modules share the same registry, you must choose with care what values you use as keys, to avoid collisions</strong>. String keys are particularly useful when you want to allow other independent libraries to access your data, because all they need to know is the key name. For those keys, there is no bulletproof method of choosing names, but there are some good practices, such as avoiding common names and prefixing your names with the library name or something like it. (Prefixes like lua or lualib are not good choices.)</p>
</blockquote>
<p>registry key如何避免冲突；<br>number类型的key留给引用系统；</p>
<blockquote>
<p>You should <strong>never use numbers as keys in the registry</strong>, because such keys are reserved for the <strong>reference system</strong>. This system comprises a couple of functions in the auxiliary library that allow you to store values in a table without worrying about how to create unique names. Function <strong>luaL_ref</strong> creates new references:<br> <code>int r = luaL_ref(L, LUA_REGISTRYINDEX);</code><br>The previous call pops a value from the stack, stores it into the registry with a fresh integer key, and returns this key. We call this key a reference.<br>As the name implies, we use references mainly when we need to store a reference to a Lua value inside a C structure. As we have seen, we should never store pointers to Lua strings outside the C function that retrieved them. Moreover, Lua does not even offer pointers to other objects, such as tables or functions. So, we cannot refer to Lua objects through pointers. Instead, when we need such pointers, we <strong>create a reference and store it in C</strong>.<br>To push the value associated with a reference r onto the stack, we simply write this:<br><code>lua_rawgeti(L, LUA_REGISTRYINDEX, r);</code><br>Finally, to release both the value and the reference, we call luaL_unref:<br> <code>luaL_unref(L, LUA_REGISTRYINDEX, r);</code><br>After this call, a new call to luaL_ref may return again this reference.<br>The reference system treats nil as a special case. Whenever we call luaL_ref for a nil value, it does not create a new reference, but instead returns the<br>constant reference <strong>LUA_REFNIL</strong>. The next call has no effect: luaL_unref(L, LUA_REGISTRYINDEX, LUA_REFNIL);<br>The next one pushes a nil, as expected:<br><code>lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_REFNIL);</code><br>The reference system also defines the constant <strong>LUA_NOREF</strong>, which is an integer different from any valid reference. <strong>It is useful to mark references as invalid.</strong><br>Another bulletproof method to create keys into the registry is to use as key the address of a static variable in your code: the C link editor ensures that this key is unique among all libraries. To use this option, you need the function lua_pushlightuserdata, which pushes on the Lua stack a value representing a C pointer. The following code shows how to store and retrieve a string from the registry using this method:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* variable with a unique address */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> Key = <span class="string">'k'</span>;</span><br><span class="line"><span class="comment">/* store a string */</span></span><br><span class="line">lua_pushlightuserdata(L, (<span class="keyword">void</span> *)&amp;Key);  <span class="comment">/* push address */</span></span><br><span class="line">lua_pushstring(L, myStr);  <span class="comment">/* push value */</span></span><br><span class="line">lua_settable(L, LUA_REGISTRYINDEX);  <span class="comment">/* registry[&amp;Key] = myStr */</span></span><br><span class="line"><span class="comment">/* retrieve a string */</span></span><br><span class="line">lua_pushlightuserdata(L, (<span class="keyword">void</span> *)&amp;Key);  <span class="comment">/* push address */</span></span><br><span class="line">lua_gettable(L, LUA_REGISTRYINDEX);  <span class="comment">/* retrieve value */</span></span><br><span class="line">myStr = lua_tostring(L, <span class="number">-1</span>);  <span class="comment">/* convert to string */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>We will discuss light userdata in more detail in Section 29.5.<br>To simplify the use of variable addresses as unique keys, Lua 5.2 introduced two new functions: <strong>lua_rawgetp and lua_rawsetp</strong>. They are similar to lua_rawgeti-lua_rawseti but, instead of integers, they use C pointers (trans- lated to light userdata) as keys. With them, we can write the previous code like<br>this:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> Key = <span class="string">'k'</span>;</span><br><span class="line"><span class="comment">/* store a string */</span></span><br><span class="line">lua_pushstring(L, myStr);</span><br><span class="line">lua_rawsetp(L, LUA_REGISTRYINDEX, (<span class="keyword">void</span> *)&amp;Key);</span><br><span class="line"><span class="comment">/* retrieve a string */</span></span><br><span class="line">lua_rawgetp(L, LUA_REGISTRYINDEX, (<span class="keyword">void</span> *)&amp;Key);</span><br><span class="line">myStr = lua_tostring(L, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Both functions use raw accesses. As the registry usually does not have a meta- table, a raw access has the same behavior of a regular access, and it is slightly more efficient.</p>
</blockquote>
<h4 id="Upvalues"><a href="#Upvalues" class="headerlink" title="Upvalues"></a>Upvalues</h4><blockquote>
<p>While the registry offers global variables, the upvalue mechanism implements <strong>an equivalent of C static variables</strong> that are visible only inside a particular<br>function. Every time you create a new C function in Lua, you can associate with it any number of upvalues; each upvalue can hold a single Lua value. Later, when the function is called, it has free access to any of its upvalues, using pseudo-indices.</p>
</blockquote>
<p>A function only has an upvalue on _ENV if it references a global variable. </p>
<blockquote>
<p>We call this association of a C function with its upvalues a closure. A C closure is a C approximation to a Lua closure. In particular, you can create different closures using the same function code, but with different upvalues.<br>To see a simple example, let us create a newCounter function in C. This function is a factory: it returns a new counter function each time it is called. Although all counters share the same C code, each one keeps its own independent counter. The factory function is like this:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">counter</span> <span class="params">(lua_State *L)</span></span>;  <span class="comment">/* forward declaration */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newCounter</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    lua_pushinteger(L, <span class="number">0</span>);</span><br><span class="line">    lua_pushcclosure(L, &amp;counter, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The key function here is lua_pushcclosure, which creates a new closure. Its second argument is the base function (counter, in the example) and the third is the number of upvalues (1, in the example). Before creating a new closure, we must push on the stack the initial values for its upvalues. In our example, we push the number 0 as the initial value for the single upvalue. As expected, lua_pushcclosure leaves the new closure on the stack, so the closure is ready to be returned as the result of newCounter.<br>Now, let us see the definition of counter:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">counter</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = lua_tointeger(L, lua_upvalueindex(<span class="number">1</span>));</span><br><span class="line">    lua_pushinteger(L, ++val);  <span class="comment">/* new value */</span></span><br><span class="line">    lua_pushvalue(L, <span class="number">-1</span>);  <span class="comment">/* duplicate it */</span></span><br><span class="line">    lua_replace(L, lua_upvalueindex(<span class="number">1</span>));  <span class="comment">/* update upvalue */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* return new value */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Here, the key element is macro <strong>lua_upvalueindex</strong>, which produces the pseudo-index of an upvalue. In particular, the expression lua_upvalueindex(1) results in the pseudo-index of the first upvalue of the running function. Again, this pseudo-index is like any stack index, except that it does not live in the stack. So, the call to lua_tointeger retrieves the current value of the first (and only) upvalue as a number. Then, function counter pushes the new value ++val, makes a copy of it, and uses one of the copies to replace the upvalue’s value. Finally, it returns the other copy as its return value.</p>
</blockquote>
<blockquote>
<p>As a more advanced example, we will implement tuples using upvalues. A tuple is a kind of constant record with anonymous fields; you can retrieve a specific field with a numerical index, or you can retrieve all fields at once. In our implementation, we represent tuples as functions that store their values in their upvalues. When called with a numerical argument, the function returns that specific field. When called without arguments, it returns all its fields. The following code illustrates the use of tuples:</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = tuple.new(<span class="number">10</span>, <span class="string">"hi"</span>, &#123;&#125;, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(x(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(x())</span><br><span class="line"><span class="comment">--&gt; 10</span></span><br><span class="line"><span class="comment">--&gt; hi</span></span><br><span class="line"><span class="comment">--&gt; 10  hi  table: 0x8087878  3</span></span><br></pre></td></tr></table></figure>

<p><em>Listing 28.5. An implementation of tuples:</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">t_tuple</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op = luaL_optint(L, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">0</span>) &#123;  <span class="comment">/* no arguments? */</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">/* push each valid upvalue onto the stack */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; !lua_isnone(L, lua_upvalueindex(i)); i++)</span><br><span class="line">            lua_pushvalue(L, lua_upvalueindex(i));</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span>;  <span class="comment">/* number of values in the stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* get field 'op' */</span></span><br><span class="line">        luaL_argcheck(L, <span class="number">0</span> &lt; op, <span class="number">1</span>, <span class="string">"index out of range"</span>);</span><br><span class="line">        <span class="keyword">if</span> (lua_isnone(L, lua_upvalueindex(op)))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* no such field */</span></span><br><span class="line">        lua_pushvalue(L, lua_upvalueindex(op));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">t_new</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    lua_pushcclosure(L, t_tuple, lua_gettop(L));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">tuplelib</span> [] = &#123;</span></span><br><span class="line">    &#123;<span class="string">"new"</span>, t_new&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaopen_tuple</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    luaL_newlib(L, tuplelib);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>In C, we represent all tuples by the same function t_tuple, presented in Listing 28.5. Because we can call a tuple with or without a numeric argument, t_tuple uses luaL_optint to get its optional argument. The luaL_optint function is similar to luaL_checkint, but it does not complain if the argument is absent; instead, it returns a given default value (0, in the example).<br>When we index a non-existent upvalue, the result is a pseudo-value whose type is LUA_TNONE. (When we access a stack index above the current top, we also get a pseudo-value with this type LUA_TNONE.) So, our t_tuple function uses lua_isnone to test whether it has a given upvalue. However, we should never call lua_upvalueindex with a negative index, so we must check for this condition when the user provides the index. The luaL_argcheck function checks any given condition, raising an error if necessary.<br>The function to create tuples, t_new (also in Listing 28.5), is trivial: because its arguments are already in the stack, it just has to call lua_pushcclosure to create a closure of t_tuple with all its arguments as upvalues. Finally, array tuplelib and function luaopen_tuple (also in Listing 28.5) are the standard code to create a library tuple with that single function new.</p>
</blockquote>
<h4 id="Shared-upvalues"><a href="#Shared-upvalues" class="headerlink" title="Shared upvalues"></a>Shared upvalues</h4><blockquote>
<p>Frequently, we need to share some values or variables among all functions in a library. Although we can use the registry for that task, we can also use upvalues. <strong>Unlike Lua closures, C closures cannot share upvalues.</strong> Each closure has its own independent upvalues. However, we can set the upvalues of different functions to refer to a common table, so that this table becomes a common environment where all those functions can share data.<br>Lua 5.2 offers a function that eases the task of sharing an upvalue among all functions of a library. We have been opening C libraries with luaL_newlib. Lua implements this function as the following macro:</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define luaL_newlib(L,l)  \</span><br><span class="line">     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>The macro luaL_newlibtable just creates a new table for the library. (We could use lua_newtable as well, but this macro uses lua_createtable to create a table with a preallocated size optimal for the number of functions in the given library.)</p>
<blockquote>
<p>Function luaL_setfuncs adds the functions in the list l to that new table, which is on the top of the stack.<br>The third parameter to luaL_setfuncs is what we are interested here. <strong>It tells how many upvalues the new functions in the library will have.</strong> The initial value for these upvalues should be in the stack, as happens with lua_pushcclosure. Therefore, to create a library where all functions share a common table as their single upvalue, we can use the following code:</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* <span class="built_in">create</span> library <span class="built_in">table</span> (<span class="string">'lib'</span> is its list of functions) */</span><br><span class="line">luaL_newlibtable(L, lib);</span><br><span class="line">/* <span class="built_in">create</span> shared upvalue */</span><br><span class="line">lua_newtable(L);</span><br><span class="line">/* add functions <span class="keyword">in</span> list <span class="string">'lib'</span> to the new library, sharing</span><br><span class="line">   previous <span class="built_in">table</span> as upvalue */</span><br><span class="line">luaL_setfuncs(L, lib, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The last call also removes the shared table from the stack, leaving there only the new library.</p>
</blockquote>
<h4 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h4><blockquote>
<p>Exercise 28.1: Implement a filter function in C. It should receive a list and a predicate and return a new list with all elements from the given list that satisfy the predicate:</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = filter(&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">-4</span>, <span class="number">5</span>&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span> <span class="keyword">return</span> x &lt; <span class="number">5</span> <span class="keyword">end</span>)</span><br><span class="line"><span class="comment">-- t = &#123;1, 3, -4&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>(A predicate is just a function that tests some condition, returning a boolean.)<br>Exercise 28.2: Modify function l_split (from Listing 28.2) so that it can work with strings containing zeros. (Among other changes, it should use memchr instead of strchr.)<br>Exercise28.3: Reimplementthetransliteratefunction(Exercise21.3)inC.<br>Exercise 28.4: Implement a library with a modification of transliterate so that the transliteration table is not given as an argument, but instead is kept by the library. Your library should offer the following functions:</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lib.settrans (<span class="built_in">table</span>)</span><br><span class="line">lib.gettrans ()</span><br><span class="line">lib.tranliterate(s)</span><br><span class="line"><span class="comment">-- set the transliteration table</span></span><br><span class="line"><span class="comment">-- get the transliteration table</span></span><br><span class="line"><span class="comment">-- transliterate 's' according to the current table</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Use the registry to keep the transliteration table.<br>Exercise 28.5: Repeat the previous exercise using an upvalue to keep the transliteration table.<br>Exercise28.6: Doyouthinkitisagooddesigntokeepthetransliterationtable as part of the state of the library, instead of being a parameter to tranliterate?</p>
</blockquote>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>

    
        

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binnnliu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Know Why">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/27/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-27 22:26:44" itemprop="dateCreated datePublished" datetime="2019-07-27T22:26:44+08:00">2019-07-27</time>
            </span>
          

          

          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>

    
        

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/13/jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binnnliu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Know Why">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/10/13/jvm/" class="post-title-link" itemprop="url">JVM学习</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-10-13 01:32:29" itemprop="dateCreated datePublished" datetime="2016-10-13T01:32:29+08:00">2016-10-13</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-27 23:14:41" itemprop="dateModified" datetime="2019-07-27T23:14:41+08:00">2019-07-27</time>
              </span>
            
          

          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。</p>
<p>Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。 </p>
<p>javac<br>java -cp ~/WorkSpace/Projects/Java/HelloWorld/src/ org.lecloud.HelloWorld</p>
<p>Bootstrap classes - Classes that comprise the Java platform, including the classes in rt.jar and several other important jar files.<br>Extension classes - Classes that use the Java Extension mechanism. These are bundled as .jar files located in the extensions directory.<br>User classes - Classes defined by developers and third parties that do not take advantage of the extension mechanism. You identify the location of these classes using the -classpath option on the command line (the preferred method) or by using the CLASSPATH environment variable. (See Setting the Classpath for Windows or Solaris.)</p>
<p>If a referenced class is defined in both a class file and source file, javadoc always uses the source file (javadoc never compiles source files).</p>
<p>jar -cfvm Hello.jar META-INF/MANIFEST.MF org/<br>jar -cfve Hello.jar org.lecloud.HelloWorld org/<br>java -jar Hello.jar</p>
<p>java -cp Hello.jar org.lecloud.HelloWorld</p>
<p>JLI_Launch</p>
<p>ContinueInNewThread</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">JVMInit(InvocationFunctions* ifn, jlong threadStackSize,</span><br><span class="line">        <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv,</span><br><span class="line">        <span class="keyword">int</span> mode, <span class="keyword">char</span> *what, <span class="keyword">int</span> ret)</span><br><span class="line">&#123;</span><br><span class="line">    ShowSplashScreen();</span><br><span class="line">    <span class="keyword">return</span> ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If C is not an array class, it is created by loading a binary representation of C (§4 (The<br>class File Format)) using a class loader. Array classes do not have an external<br>binary representation; they are created by the Java Virtual Machine rather than by<br>a class loader.</p>
<p>A class loader L may create C by defining it directly or by delegating to another<br>class loader. If L creates C directly, we say that L defines C or, equivalently, that L<br>is the defining loader of C.</p>
<p>An array class is created directly by the Java Virtual Machine, not by a class loader. </p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>

    
        

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/03/19/epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binnnliu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Know Why">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2014/03/19/epoll/" class="post-title-link" itemprop="url">两篇微博引发的思考</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2014-03-19 01:32:29" itemprop="dateCreated datePublished" datetime="2014-03-19T01:32:29+08:00">2014-03-19</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-27 23:15:09" itemprop="dateModified" datetime="2019-07-27T23:15:09+08:00">2019-07-27</time>
              </span>
            
          

          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前段时间微博上注意到[叔度] <a href="http://weibo.com/tshudu" target="_blank" rel="noopener">7</a>，发了两篇关于面试的微博：</p>
<blockquote>
<p>一些小伙伴们写网络程序的一个坏习惯是连接建立后就挂上可写事件，这是很浪费的。正确的方法是先写，写不下去才挂上可写事件。另外，可写事件其实不是事件，它只是判断发送缓冲区是否还有空间，它是被底层的TCP事件给附带上来的。附图是Linux内核源码实现。<img src="/img/sendbufevent.jpg" alt="enter image description here"></p>
</blockquote>
<blockquote>
<p>对于非阻塞的connect，返回EINPROGRESS之后要加fd到epoll的可写事件监视集合里面，等fd可写了之后记得要调用getsockopt判断SOL_SOCKET的SO_ERROR值是否为0！非0表示连接失败。</p>
</blockquote>
<p><strong>EPOLL使用</strong></p>
<ul>
<li>ET  only noblocking mode<pre><code>处理方式：</code></pre><ul>
<li>读:只要可读，就一直读，直到返回0，或者 errno = EAGAIN</li>
<li>写:只要可写，就一直写，直到数据发送完，或者 errno = EAGAIN</li>
</ul>
</li>
<li>LT</li>
</ul>
<p>分析:一旦建立链接就挂可写事件(noblocking mode)：</p>
<ul>
<li>若在ET模式下，其实还好,相比与LT模式。哈..</li>
<li>若在LT模式下，将会不停的触发！</li>
</ul>
<p>如何做呢。正如叔度所说，先写，直到errno=EAGIN。挂载写事件，在epoll的驱动下完成全部内容的发送。当然nginx就是这么实现的。ngx_http_write，但是LT模式下，需不需要触发后从epoll中移出此可写事件呢。</p>
<p>问题：<br>    nginx使用了何种触发方式？<br>listen的socket用的水平触发，而accept之后的端口使用的是边沿触发。为何这么麻烦呢?<br>1.listen的fd使用水平触发是因为害怕丢失链接；其实使用边沿触发也有解决办法：用while循环抱住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。nginx有个配置选项：[multi_accept] <a href="http://nginx.org/en/docs/ngx_core_module.html#multi_accept" target="_blank" rel="noopener">6</a>,这是为啥？莫非是为了减少epoll_wait的系统调用?<br>2.使用ET可以有效的减少系统调用，但是ET，LT哪种更高效，貌似没用确切的结论。[ET理论上可以比LT少带来一些系统调用，所以更省一些。具体的性能提高有多少，要看应用场景。不过绝大部分场景下，LT是足够的。] <a href="http://www.zhihu.com/question/20502870" target="_blank" rel="noopener">4</a> </p>
<p>nginx水平触发代码如下：若nginx配置[accept_mutex] <a href="http://nginx.org/en/docs/ngx_core_module.html#accept_mutex" target="_blank" rel="noopener">5</a> on时会调用如下函数  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_enable_accept_events(<span class="keyword">ngx_cycle_t</span> *cycle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>         i;</span><br><span class="line">    <span class="keyword">ngx_listening_t</span>   *ls;</span><br><span class="line">    <span class="keyword">ngx_connection_t</span>  *c;</span><br><span class="line"></span><br><span class="line">    ls = cycle-&gt;listening.elts;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cycle-&gt;listening.nelts; i++) &#123;</span><br><span class="line"></span><br><span class="line">        c = ls[i].connection;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;read-&gt;active) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ngx_event_flags &amp; NGX_USE_RTSIG_EVENT) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ngx_add_conn(c) == NGX_ERROR) &#123;</span><br><span class="line">                <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ngx_add_event(c-&gt;read, NGX_READ_EVENT, <span class="number">0</span>) == NGX_ERROR) &#123;</span><br><span class="line">                <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一道面试题目：<br>使用Linux epoll模型，水平触发模式；当socket可写时，会不停的触发socket可写的事件，如何处理？</p>
<p>另一个问题：</p>
<p>直接看man 2 connect:</p>
<blockquote>
<p>EINPROGRESS<br>The socket is non-blocking and the connection cannot be completed immediately.  It is possible to select(2) or poll(2) for completion by selecting the socket for writing.After select(2) indicates writability, use getsockopt(2) to read the SO_ERROR option at level SOL_SOCKET to determine whether connect()  completed  successfully  (SO_ERROR  is zero) or unsuccessfully (SO_ERROR is one of the usual error codes listed here, explaining the reason for the failure).</p>
</blockquote>
<p>但是为什么呢？不成功也会返回可写事件？这是必须的。不管成功或者失败，总需要给client端一个交代吧。</p>
<p><strong>缓冲区</strong></p>
<p>发送缓冲区(send buffer)<br>ex:发送一个14M的buffer–公司客户端某些同事，就是在nonblocking模式下发送14m文件的，而且他就send了一次。<br>1.block模式下，等待所有的buffer发送完后返回。block方式有可能返回小于buffer长度的值么？嗯，是的。在对方异常关闭或超时是会造成返回小于buffer长度的值如果对端返回rst时，继续写的话会产生SIGPIPE,这里需要特别注意，因为sigpipe默认处理是关闭进程！一般情况下，需要捕捉此信号；<br>2.noblocking模式下，若返回值为-1，errno=EAGAIN,则加入侦听；若返回值为大于0,则循环继续发送；</p>
<p>这个要说下nginx：<br>当然如果发送文件的话，nginx用的sendfile。<br>sendfile的好处是啥呢？减少copy次数。<br>这里必须要解释下copy为啥费时费力的：<br><strong>copy一般情况下需要cpu,寄存器,一次只能copy 32bit,所以一个指令周期只能copy 32bit。</strong>所以出现了DMA,sendbuf,splice,cow等技术。nginx在upstream也做了优化。具体见：[代理服务器中的内容防拷贝技术] <a href="http://blog.csdn.net/brainkick/article/details/9843009" target="_blank" rel="noopener">2</a> ,也因此有了面试题目：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *src,<span class="keyword">void</span> *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如何实现更快...</span></span><br><span class="line">    <span class="comment">//可以转为int *类型这个，一个指令周期就可以最大化的copy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就有了内存对齐。写到这里忽然想起另一个无关的东西:RingBuffer的实现，里面有个[cache_line_padding] <a href="http://ifeve.com/disruptor-cacheline-padding/" target="_blank" rel="noopener">3</a> 跟这个有异曲同工之妙，不过跟copy无关是关于无锁队列的。可是sendfile就好了么？nginx还有更深层的优化。正常情况下，nginx是设置tcp_nodelay;但是在sendfile时，会设置tcp_cork。</p>
<p>在传输文件时，我们可以做那些优化呢？</p>
<p>接收缓冲区(read buffer)<br>    epoll返回可写事件，调用recv返回0，则表示对端关闭。对端close，若拔网线呢？keepalive情况下会触发可写事件。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
  <p class="site-author-name" itemprop="name">binnnliu</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>


  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    

    

    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>













          
          
        </div>
      </div>

      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">binnnliu</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    

  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
















  
  









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  























<script>
// GET RESPONSIVE HEIGHT PASSED FROM IFRAME

window.addEventListener("message", function(e) {
  var data = e.data;
  if ((typeof data === 'string') && (data.indexOf('ciu_embed') > -1)) {
    var featureID = data.split(':')[1];
    var height = data.split(':')[2];
    $(`iframe[data-feature=${featureID}]`).height(parseInt(height) + 30);
  }
}, false);
</script>








  

</body>
</html>
